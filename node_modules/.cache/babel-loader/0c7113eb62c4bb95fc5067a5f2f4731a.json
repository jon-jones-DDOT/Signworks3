{"ast":null,"code":"import _classCallCheck from \"C:\\\\Projects\\\\Signworks3\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Projects\\\\Signworks3\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n/* Geodesy representation conversion functions                        (c) Chris Veness 2002-2019  */\n\n/*                                                                                   MIT Licence  */\n\n/* www.movable-type.co.uk/scripts/latlong.html                                                    */\n\n/* www.movable-type.co.uk/scripts/js/geodesy/geodesy-library.html#dms                             */\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n/* eslint no-irregular-whitespace: [2, { skipComments: true }] */\n\n/**\n * Latitude/longitude points may be represented as decimal degrees, or subdivided into sexagesimal\n * minutes and seconds. This module provides methods for parsing and representing degrees / minutes\n * / seconds.\n *\n * @module dms\n */\n\n/* Degree-minutes-seconds (& cardinal directions) separator character */\nvar dmsSeparator = \"\\u202F\"; // U+202F = 'narrow no-break space'\n\n/**\n * Functions for parsing and representing degrees / minutes / seconds.\n */\n\nvar Dms =\n/*#__PURE__*/\nfunction () {\n  function Dms() {\n    _classCallCheck(this, Dms);\n  }\n\n  _createClass(Dms, null, [{\n    key: \"parse\",\n\n    /**\n     * Parses string representing degrees/minutes/seconds into numeric degrees.\n     *\n     * This is very flexible on formats, allowing signed decimal degrees, or deg-min-sec optionally\n     * suffixed by compass direction (NSEW); a variety of separators are accepted. Examples -3.62,\n     * '3 37 12W', '3°37′12″W'.\n     *\n     * Thousands/decimal separators must be comma/dot; use Dms.fromLocale to convert locale-specific\n     * thousands/decimal separators.\n     *\n     * @param   {string|number} dms - Degrees or deg/min/sec in variety of formats.\n     * @returns {number}        Degrees as decimal number.\n     *\n     * @example\n     *   const lat = Dms.parse('51° 28′ 40.37″ N');\n     *   const lon = Dms.parse('000° 00′ 05.29″ W');\n     *   const p1 = new LatLon(lat, lon); // 51.4779°N, 000.0015°W\n     */\n    value: function parse(dms) {\n      // check for signed decimal degrees without NSEW, if so return it directly\n      if (!isNaN(parseFloat(dms)) && isFinite(dms)) return Number(dms); // strip off any sign or compass dir'n & split out separate d/m/s\n\n      var dmsParts = String(dms).trim().replace(/^-/, '').replace(/[NSEW]$/i, '').split(/[^0-9.,]+/);\n      if (dmsParts[dmsParts.length - 1] == '') dmsParts.splice(dmsParts.length - 1); // from trailing symbol\n\n      if (dmsParts == '') return NaN; // and convert to decimal degrees...\n\n      var deg = null;\n\n      switch (dmsParts.length) {\n        case 3:\n          // interpret 3-part result as d/m/s\n          deg = dmsParts[0] / 1 + dmsParts[1] / 60 + dmsParts[2] / 3600;\n          break;\n\n        case 2:\n          // interpret 2-part result as d/m\n          deg = dmsParts[0] / 1 + dmsParts[1] / 60;\n          break;\n\n        case 1:\n          // just d (possibly decimal) or non-separated dddmmss\n          deg = dmsParts[0]; // check for fixed-width unseparated format eg 0033709W\n          //if (/[NS]/i.test(dmsParts)) deg = '0' + deg;  // - normalise N/S to 3-digit degrees\n          //if (/[0-9]{7}/.test(deg)) deg = deg.slice(0,3)/1 + deg.slice(3,5)/60 + deg.slice(5)/3600;\n\n          break;\n\n        default:\n          return NaN;\n      }\n\n      if (/^-|[WS]$/i.test(dms.trim())) deg = -deg; // take '-', west and south as -ve\n\n      return Number(deg);\n    }\n    /**\n     * Converts decimal degrees to deg/min/sec format\n     *  - degree, prime, double-prime symbols are added, but sign is discarded, though no compass\n     *    direction is added.\n     *  - degrees are zero-padded to 3 digits; for degrees latitude, use .slice(1) to remove leading\n     *    zero.\n     *\n     * @private\n     * @param   {number} deg - Degrees to be formatted as specified.\n     * @param   {string} [format=d] - Return value as 'd', 'dm', 'dms' for deg, deg+min, deg+min+sec.\n     * @param   {number} [dp=4|2|0] - Number of decimal places to use – default 4 for d, 2 for dm, 0 for dms.\n     * @returns {string} Degrees formatted as deg/min/secs according to specified format.\n     */\n\n  }, {\n    key: \"toDms\",\n    value: function toDms(deg) {\n      var format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'd';\n      var dp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n      if (isNaN(deg)) return null; // give up here if we can't make a number from deg\n\n      if (typeof deg == 'string' && deg.trim() == '') return null;\n      if (typeof deg == 'boolean') return null;\n      if (deg == Infinity) return null;\n      if (deg == null) return null; // default values\n\n      if (dp === undefined) {\n        switch (format) {\n          case 'd':\n          case 'deg':\n            dp = 4;\n            break;\n\n          case 'dm':\n          case 'deg+min':\n            dp = 2;\n            break;\n\n          case 'dms':\n          case 'deg+min+sec':\n            dp = 0;\n            break;\n\n          default:\n            format = 'd';\n            dp = 4;\n            break;\n          // be forgiving on invalid format\n        }\n      }\n\n      deg = Math.abs(deg); // (unsigned result ready for appending compass dir'n)\n\n      var dms = null,\n          d = null,\n          m = null,\n          s = null;\n\n      switch (format) {\n        default: // invalid format spec!\n\n        case 'd':\n        case 'deg':\n          d = deg.toFixed(dp); // round/right-pad degrees\n\n          if (d < 100) d = '0' + d; // left-pad with leading zeros (note may include decimals)\n\n          if (d < 10) d = '0' + d;\n          dms = d + '°';\n          break;\n\n        case 'dm':\n        case 'deg+min':\n          d = Math.floor(deg); // get component deg\n\n          m = (deg * 60 % 60).toFixed(dp); // get component min & round/right-pad\n\n          if (m == 60) {\n            m = 0 .toFixed(dp);\n            d++;\n          } // check for rounding up\n\n\n          d = ('000' + d).slice(-3); // left-pad with leading zeros\n\n          if (m < 10) m = '0' + m; // left-pad with leading zeros (note may include decimals)\n\n          dms = d + '°' + Dms.separator + m + '′';\n          break;\n\n        case 'dms':\n        case 'deg+min+sec':\n          d = Math.floor(deg); // get component deg\n\n          m = Math.floor(deg * 3600 / 60) % 60; // get component min\n\n          s = (deg * 3600 % 60).toFixed(dp); // get component sec & round/right-pad\n\n          if (s == 60) {\n            s = 0 .toFixed(dp);\n            m++;\n          } // check for rounding up\n\n\n          if (m == 60) {\n            m = 0;\n            d++;\n          } // check for rounding up\n\n\n          d = ('000' + d).slice(-3); // left-pad with leading zeros\n\n          m = ('00' + m).slice(-2); // left-pad with leading zeros\n\n          if (s < 10) s = '0' + s; // left-pad with leading zeros (note may include decimals)\n\n          dms = d + '°' + Dms.separator + m + '′' + Dms.separator + s + '″';\n          break;\n      }\n\n      return dms;\n    }\n    /**\n     * Converts numeric degrees to deg/min/sec latitude (2-digit degrees, suffixed with N/S).\n     *\n     * @param   {number} deg - Degrees to be formatted as specified.\n     * @param   {string} [format=d] - Return value as 'd', 'dm', 'dms' for deg, deg+min, deg+min+sec.\n     * @param   {number} [dp=4|2|0] - Number of decimal places to use – default 4 for d, 2 for dm, 0 for dms.\n     * @returns {string} Degrees formatted as deg/min/secs according to specified format.\n     *\n     * @example\n     *   const lat = Dms.toLat(-3.62, 'dms'); // 3°37′12″S\n     */\n\n  }, {\n    key: \"toLat\",\n    value: function toLat(deg, format, dp) {\n      var lat = Dms.toDms(Dms.wrap90(deg), format, dp);\n      return lat === null ? '–' : lat.slice(1) + Dms.separator + (deg < 0 ? 'S' : 'N'); // knock off initial '0' for lat!\n    }\n    /**\n     * Convert numeric degrees to deg/min/sec longitude (3-digit degrees, suffixed with E/W).\n     *\n     * @param   {number} deg - Degrees to be formatted as specified.\n     * @param   {string} [format=d] - Return value as 'd', 'dm', 'dms' for deg, deg+min, deg+min+sec.\n     * @param   {number} [dp=4|2|0] - Number of decimal places to use – default 4 for d, 2 for dm, 0 for dms.\n     * @returns {string} Degrees formatted as deg/min/secs according to specified format.\n     *\n     * @example\n     *   const lon = Dms.toLon(-3.62, 'dms'); // 3°37′12″W\n     */\n\n  }, {\n    key: \"toLon\",\n    value: function toLon(deg, format, dp) {\n      var lon = Dms.toDms(Dms.wrap180(deg), format, dp);\n      return lon === null ? '–' : lon + Dms.separator + (deg < 0 ? 'W' : 'E');\n    }\n    /**\n     * Converts numeric degrees to deg/min/sec as a bearing (0°..360°).\n     *\n     * @param   {number} deg - Degrees to be formatted as specified.\n     * @param   {string} [format=d] - Return value as 'd', 'dm', 'dms' for deg, deg+min, deg+min+sec.\n     * @param   {number} [dp=4|2|0] - Number of decimal places to use – default 4 for d, 2 for dm, 0 for dms.\n     * @returns {string} Degrees formatted as deg/min/secs according to specified format.\n     *\n     * @example\n     *   const lon = Dms.toBrng(-3.62, 'dms'); // 356°22′48″\n     */\n\n  }, {\n    key: \"toBrng\",\n    value: function toBrng(deg, format, dp) {\n      var brng = Dms.toDms(Dms.wrap360(deg), format, dp);\n      return brng === null ? '–' : brng.replace('360', '0'); // just in case rounding took us up to 360°!\n    }\n    /**\n     * Converts DMS string from locale thousands/decimal separators to JavaScript comma/dot separators\n     * for subsequent parsing.\n     *\n     * Both thousands and decimal separators must be followed by a numeric character, to facilitate\n     * parsing of single lat/long string (in which whitespace must be left after the comma separator).\n     *\n     * @param   {string} str - Degrees/minutes/seconds formatted with locale separators.\n     * @returns {string} Degrees/minutes/seconds formatted with standard Javascript separators.\n     *\n     * @example\n     *   const lat = Dms.fromLocale('51°28′40,12″N');                          // '51°28′40.12″N' in France\n     *   const p = new LatLon(Dms.fromLocale('51°28′40,37″N, 000°00′05,29″W'); // '51.4779°N, 000.0015°W' in France\n     */\n\n  }, {\n    key: \"fromLocale\",\n    value: function fromLocale(str) {\n      var locale = 123456.789.toLocaleString();\n      var separator = {\n        thousands: locale.slice(3, 4),\n        decimal: locale.slice(7, 8)\n      };\n      return str.replace(separator.thousands, '⁜').replace(separator.decimal, '.').replace('⁜', ',');\n    }\n    /**\n     * Converts DMS string from JavaScript comma/dot thousands/decimal separators to locale separators.\n     *\n     * Can also be used to format standard numbers such as distances.\n     *\n     * @param   {string} str - Degrees/minutes/seconds formatted with standard Javascript separators.\n     * @returns {string} Degrees/minutes/seconds formatted with locale separators.\n     *\n     * @example\n     *   const Dms.toLocale('123,456.789');                   // '123.456,789' in France\n     *   const Dms.toLocale('51°28′40.12″N, 000°00′05.31″W'); // '51°28′40,12″N, 000°00′05,31″W' in France\n     */\n\n  }, {\n    key: \"toLocale\",\n    value: function toLocale(str) {\n      var locale = 123456.789.toLocaleString();\n      var separator = {\n        thousands: locale.slice(3, 4),\n        decimal: locale.slice(7, 8)\n      };\n      return str.replace(/,([0-9])/, '⁜$1').replace('.', separator.decimal).replace('⁜', separator.thousands);\n    }\n    /**\n     * Returns compass point (to given precision) for supplied bearing.\n     *\n     * @param   {number} bearing - Bearing in degrees from north.\n     * @param   {number} [precision=3] - Precision (1:cardinal / 2:intercardinal / 3:secondary-intercardinal).\n     * @returns {string} Compass point for supplied bearing.\n     *\n     * @example\n     *   const point = Dms.compassPoint(24);    // point = 'NNE'\n     *   const point = Dms.compassPoint(24, 1); // point = 'N'\n     */\n\n  }, {\n    key: \"compassPoint\",\n    value: function compassPoint(bearing) {\n      var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;\n      if (![1, 2, 3].includes(Number(precision))) throw new RangeError(\"invalid precision \\u2018\".concat(precision, \"\\u2019\")); // note precision could be extended to 4 for quarter-winds (eg NbNW), but I think they are little used\n\n      bearing = Dms.wrap360(bearing); // normalise to range 0..360°\n\n      var cardinals = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];\n      var n = 4 * Math.pow(2, precision - 1); // no of compass points at req’d precision (1=>4, 2=>8, 3=>16)\n\n      var cardinal = cardinals[Math.round(bearing * n / 360) % n * 16 / n];\n      return cardinal;\n    }\n    /**\n     * Constrain degrees to range 0..360 (e.g. for bearings); -1 => 359, 361 => 1.\n     *\n     * @private\n     * @param {number} degrees\n     * @returns degrees within range 0..360.\n     */\n\n  }, {\n    key: \"wrap360\",\n    value: function wrap360(degrees) {\n      if (0 <= degrees && degrees < 360) return degrees; // avoid rounding due to arithmetic ops if within range\n\n      return (degrees % 360 + 360) % 360; // sawtooth wave p:360, a:360\n    }\n    /**\n     * Constrain degrees to range -180..+180 (e.g. for longitude); -181 => 179, 181 => -179.\n     *\n     * @private\n     * @param {number} degrees\n     * @returns degrees within range -180..+180.\n     */\n\n  }, {\n    key: \"wrap180\",\n    value: function wrap180(degrees) {\n      if (-180 < degrees && degrees <= 180) return degrees; // avoid rounding due to arithmetic ops if within range\n\n      return (degrees + 540) % 360 - 180; // sawtooth wave p:180, a:±180\n    }\n    /**\n     * Constrain degrees to range -90..+90 (e.g. for latitude); -91 => -89, 91 => 89.\n     *\n     * @private\n     * @param {number} degrees\n     * @returns degrees within range -90..+90.\n     */\n\n  }, {\n    key: \"wrap90\",\n    value: function wrap90(degrees) {\n      if (-90 <= degrees && degrees <= 90) return degrees; // avoid rounding due to arithmetic ops if within range\n\n      return Math.abs((degrees % 360 + 270) % 360 - 180) - 90; // triangle wave p:360 a:±90 TODO: fix e.g. -315°\n    }\n  }, {\n    key: \"separator\",\n    // note Unicode Degree = U+00B0. Prime = U+2032, Double prime = U+2033\n\n    /**\n     * Separator character to be used to separate degrees, minutes, seconds, and cardinal directions.\n     *\n     * Default separator is U+202F ‘narrow no-break space’.\n     *\n     * To change this (e.g. to empty string or full space), set Dms.separator prior to invoking\n     * formatting.\n     *\n     * @example\n     *   import LatLon, { Dms } from '/js/geodesy/latlon-spherical.js';\n     *   const p = new LatLon(51.2, 0.33).toString('dms');  // 51° 12′ 00″ N, 000° 19′ 48″ E\n     *   Dms.separator = '';                                // no separator\n     *   const pʹ = new LatLon(51.2, 0.33).toString('dms'); // 51°12′00″N, 000°19′48″E\n     */\n    get: function get() {\n      return dmsSeparator;\n    },\n    set: function set(char) {\n      dmsSeparator = char;\n    }\n  }]);\n\n  return Dms;\n}(); // Extend Number object with methods to convert between degrees & radians\n\n\nNumber.prototype.toRadians = function () {\n  return this * Math.PI / 180;\n};\n\nNumber.prototype.toDegrees = function () {\n  return this * 180 / Math.PI;\n};\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n\nexport default Dms;","map":{"version":3,"sources":["C:\\Projects\\Signworks3\\src\\utils\\geodesy\\dms.js"],"names":["dmsSeparator","Dms","dms","isNaN","parseFloat","isFinite","Number","dmsParts","String","trim","replace","split","length","splice","NaN","deg","test","format","dp","undefined","Infinity","Math","abs","d","m","s","toFixed","floor","slice","separator","lat","toDms","wrap90","lon","wrap180","brng","wrap360","str","locale","toLocaleString","thousands","decimal","bearing","precision","includes","RangeError","cardinals","n","cardinal","round","degrees","char","prototype","toRadians","PI","toDegrees"],"mappings":"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","sourcesContent":["/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/* Geodesy representation conversion functions                        (c) Chris Veness 2002-2019  */\n/*                                                                                   MIT Licence  */\n/* www.movable-type.co.uk/scripts/latlong.html                                                    */\n/* www.movable-type.co.uk/scripts/js/geodesy/geodesy-library.html#dms                             */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n/* eslint no-irregular-whitespace: [2, { skipComments: true }] */\n\n\n/**\n * Latitude/longitude points may be represented as decimal degrees, or subdivided into sexagesimal\n * minutes and seconds. This module provides methods for parsing and representing degrees / minutes\n * / seconds.\n *\n * @module dms\n */\n\n\n/* Degree-minutes-seconds (& cardinal directions) separator character */\nlet dmsSeparator = '\\u202f'; // U+202F = 'narrow no-break space'\n\n\n/**\n * Functions for parsing and representing degrees / minutes / seconds.\n */\nclass Dms {\n\n    // note Unicode Degree = U+00B0. Prime = U+2032, Double prime = U+2033\n\n    /**\n     * Separator character to be used to separate degrees, minutes, seconds, and cardinal directions.\n     *\n     * Default separator is U+202F ‘narrow no-break space’.\n     *\n     * To change this (e.g. to empty string or full space), set Dms.separator prior to invoking\n     * formatting.\n     *\n     * @example\n     *   import LatLon, { Dms } from '/js/geodesy/latlon-spherical.js';\n     *   const p = new LatLon(51.2, 0.33).toString('dms');  // 51° 12′ 00″ N, 000° 19′ 48″ E\n     *   Dms.separator = '';                                // no separator\n     *   const pʹ = new LatLon(51.2, 0.33).toString('dms'); // 51°12′00″N, 000°19′48″E\n     */\n    static get separator()     { return dmsSeparator; }\n    static set separator(char) { dmsSeparator = char; }\n\n\n    /**\n     * Parses string representing degrees/minutes/seconds into numeric degrees.\n     *\n     * This is very flexible on formats, allowing signed decimal degrees, or deg-min-sec optionally\n     * suffixed by compass direction (NSEW); a variety of separators are accepted. Examples -3.62,\n     * '3 37 12W', '3°37′12″W'.\n     *\n     * Thousands/decimal separators must be comma/dot; use Dms.fromLocale to convert locale-specific\n     * thousands/decimal separators.\n     *\n     * @param   {string|number} dms - Degrees or deg/min/sec in variety of formats.\n     * @returns {number}        Degrees as decimal number.\n     *\n     * @example\n     *   const lat = Dms.parse('51° 28′ 40.37″ N');\n     *   const lon = Dms.parse('000° 00′ 05.29″ W');\n     *   const p1 = new LatLon(lat, lon); // 51.4779°N, 000.0015°W\n     */\n    static parse(dms) {\n        // check for signed decimal degrees without NSEW, if so return it directly\n        if (!isNaN(parseFloat(dms)) && isFinite(dms)) return Number(dms);\n\n        // strip off any sign or compass dir'n & split out separate d/m/s\n        const dmsParts = String(dms).trim().replace(/^-/, '').replace(/[NSEW]$/i, '').split(/[^0-9.,]+/);\n        if (dmsParts[dmsParts.length-1]=='') dmsParts.splice(dmsParts.length-1);  // from trailing symbol\n\n        if (dmsParts == '') return NaN;\n\n        // and convert to decimal degrees...\n        let deg = null;\n        switch (dmsParts.length) {\n            case 3:  // interpret 3-part result as d/m/s\n                deg = dmsParts[0]/1 + dmsParts[1]/60 + dmsParts[2]/3600;\n                break;\n            case 2:  // interpret 2-part result as d/m\n                deg = dmsParts[0]/1 + dmsParts[1]/60;\n                break;\n            case 1:  // just d (possibly decimal) or non-separated dddmmss\n                deg = dmsParts[0];\n                // check for fixed-width unseparated format eg 0033709W\n                //if (/[NS]/i.test(dmsParts)) deg = '0' + deg;  // - normalise N/S to 3-digit degrees\n                //if (/[0-9]{7}/.test(deg)) deg = deg.slice(0,3)/1 + deg.slice(3,5)/60 + deg.slice(5)/3600;\n                break;\n            default:\n                return NaN;\n        }\n        if (/^-|[WS]$/i.test(dms.trim())) deg = -deg; // take '-', west and south as -ve\n\n        return Number(deg);\n    }\n\n\n    /**\n     * Converts decimal degrees to deg/min/sec format\n     *  - degree, prime, double-prime symbols are added, but sign is discarded, though no compass\n     *    direction is added.\n     *  - degrees are zero-padded to 3 digits; for degrees latitude, use .slice(1) to remove leading\n     *    zero.\n     *\n     * @private\n     * @param   {number} deg - Degrees to be formatted as specified.\n     * @param   {string} [format=d] - Return value as 'd', 'dm', 'dms' for deg, deg+min, deg+min+sec.\n     * @param   {number} [dp=4|2|0] - Number of decimal places to use – default 4 for d, 2 for dm, 0 for dms.\n     * @returns {string} Degrees formatted as deg/min/secs according to specified format.\n     */\n    static toDms(deg, format='d', dp=undefined) {\n        if (isNaN(deg)) return null;  // give up here if we can't make a number from deg\n        if (typeof deg == 'string' && deg.trim() == '') return null;\n        if (typeof deg == 'boolean') return null;\n        if (deg == Infinity) return null;\n        if (deg == null) return null;\n\n        // default values\n        if (dp === undefined) {\n            switch (format) {\n                case 'd':   case 'deg':         dp = 4; break;\n                case 'dm':  case 'deg+min':     dp = 2; break;\n                case 'dms': case 'deg+min+sec': dp = 0; break;\n                default:          format = 'd'; dp = 4; break; // be forgiving on invalid format\n            }\n        }\n\n        deg = Math.abs(deg);  // (unsigned result ready for appending compass dir'n)\n\n        let dms = null, d = null, m = null, s = null;\n        switch (format) {\n            default: // invalid format spec!\n            case 'd': case 'deg':\n                d = deg.toFixed(dp);                       // round/right-pad degrees\n                if (d<100) d = '0' + d;                    // left-pad with leading zeros (note may include decimals)\n                if (d<10) d = '0' + d;\n                dms = d + '°';\n                break;\n            case 'dm': case 'deg+min':\n                d = Math.floor(deg);                       // get component deg\n                m = ((deg*60) % 60).toFixed(dp);           // get component min & round/right-pad\n                if (m == 60) { m = (0).toFixed(dp); d++; } // check for rounding up\n                d = ('000'+d).slice(-3);                   // left-pad with leading zeros\n                if (m<10) m = '0' + m;                     // left-pad with leading zeros (note may include decimals)\n                dms = d + '°'+Dms.separator + m + '′';\n                break;\n            case 'dms': case 'deg+min+sec':\n                d = Math.floor(deg);                       // get component deg\n                m = Math.floor((deg*3600)/60) % 60;        // get component min\n                s = (deg*3600 % 60).toFixed(dp);           // get component sec & round/right-pad\n                if (s == 60) { s = (0).toFixed(dp); m++; } // check for rounding up\n                if (m == 60) { m = 0; d++; }               // check for rounding up\n                d = ('000'+d).slice(-3);                   // left-pad with leading zeros\n                m = ('00'+m).slice(-2);                    // left-pad with leading zeros\n                if (s<10) s = '0' + s;                     // left-pad with leading zeros (note may include decimals)\n                dms = d + '°'+Dms.separator + m + '′'+Dms.separator + s + '″';\n                break;\n        }\n\n        return dms;\n    }\n\n\n    /**\n     * Converts numeric degrees to deg/min/sec latitude (2-digit degrees, suffixed with N/S).\n     *\n     * @param   {number} deg - Degrees to be formatted as specified.\n     * @param   {string} [format=d] - Return value as 'd', 'dm', 'dms' for deg, deg+min, deg+min+sec.\n     * @param   {number} [dp=4|2|0] - Number of decimal places to use – default 4 for d, 2 for dm, 0 for dms.\n     * @returns {string} Degrees formatted as deg/min/secs according to specified format.\n     *\n     * @example\n     *   const lat = Dms.toLat(-3.62, 'dms'); // 3°37′12″S\n     */\n    static toLat(deg, format, dp) {\n        const lat = Dms.toDms(Dms.wrap90(deg), format, dp);\n        return lat===null ? '–' : lat.slice(1) + Dms.separator + (deg<0 ? 'S' : 'N');  // knock off initial '0' for lat!\n    }\n\n\n    /**\n     * Convert numeric degrees to deg/min/sec longitude (3-digit degrees, suffixed with E/W).\n     *\n     * @param   {number} deg - Degrees to be formatted as specified.\n     * @param   {string} [format=d] - Return value as 'd', 'dm', 'dms' for deg, deg+min, deg+min+sec.\n     * @param   {number} [dp=4|2|0] - Number of decimal places to use – default 4 for d, 2 for dm, 0 for dms.\n     * @returns {string} Degrees formatted as deg/min/secs according to specified format.\n     *\n     * @example\n     *   const lon = Dms.toLon(-3.62, 'dms'); // 3°37′12″W\n     */\n    static toLon(deg, format, dp) {\n        const lon = Dms.toDms(Dms.wrap180(deg), format, dp);\n        return lon===null ? '–' : lon + Dms.separator + (deg<0 ? 'W' : 'E');\n    }\n\n\n    /**\n     * Converts numeric degrees to deg/min/sec as a bearing (0°..360°).\n     *\n     * @param   {number} deg - Degrees to be formatted as specified.\n     * @param   {string} [format=d] - Return value as 'd', 'dm', 'dms' for deg, deg+min, deg+min+sec.\n     * @param   {number} [dp=4|2|0] - Number of decimal places to use – default 4 for d, 2 for dm, 0 for dms.\n     * @returns {string} Degrees formatted as deg/min/secs according to specified format.\n     *\n     * @example\n     *   const lon = Dms.toBrng(-3.62, 'dms'); // 356°22′48″\n     */\n    static toBrng(deg, format, dp) {\n        const brng =  Dms.toDms(Dms.wrap360(deg), format, dp);\n        return brng===null ? '–' : brng.replace('360', '0');  // just in case rounding took us up to 360°!\n    }\n\n\n    /**\n     * Converts DMS string from locale thousands/decimal separators to JavaScript comma/dot separators\n     * for subsequent parsing.\n     *\n     * Both thousands and decimal separators must be followed by a numeric character, to facilitate\n     * parsing of single lat/long string (in which whitespace must be left after the comma separator).\n     *\n     * @param   {string} str - Degrees/minutes/seconds formatted with locale separators.\n     * @returns {string} Degrees/minutes/seconds formatted with standard Javascript separators.\n     *\n     * @example\n     *   const lat = Dms.fromLocale('51°28′40,12″N');                          // '51°28′40.12″N' in France\n     *   const p = new LatLon(Dms.fromLocale('51°28′40,37″N, 000°00′05,29″W'); // '51.4779°N, 000.0015°W' in France\n     */\n    static fromLocale(str) {\n        const locale = (123456.789).toLocaleString();\n        const separator = { thousands: locale.slice(3, 4), decimal: locale.slice(7, 8) };\n        return str.replace(separator.thousands, '⁜').replace(separator.decimal, '.').replace('⁜', ',');\n    }\n\n\n    /**\n     * Converts DMS string from JavaScript comma/dot thousands/decimal separators to locale separators.\n     *\n     * Can also be used to format standard numbers such as distances.\n     *\n     * @param   {string} str - Degrees/minutes/seconds formatted with standard Javascript separators.\n     * @returns {string} Degrees/minutes/seconds formatted with locale separators.\n     *\n     * @example\n     *   const Dms.toLocale('123,456.789');                   // '123.456,789' in France\n     *   const Dms.toLocale('51°28′40.12″N, 000°00′05.31″W'); // '51°28′40,12″N, 000°00′05,31″W' in France\n     */\n    static toLocale(str) {\n        const locale = (123456.789).toLocaleString();\n        const separator = { thousands: locale.slice(3, 4), decimal: locale.slice(7, 8) };\n        return str.replace(/,([0-9])/, '⁜$1').replace('.', separator.decimal).replace('⁜', separator.thousands);\n    }\n\n\n    /**\n     * Returns compass point (to given precision) for supplied bearing.\n     *\n     * @param   {number} bearing - Bearing in degrees from north.\n     * @param   {number} [precision=3] - Precision (1:cardinal / 2:intercardinal / 3:secondary-intercardinal).\n     * @returns {string} Compass point for supplied bearing.\n     *\n     * @example\n     *   const point = Dms.compassPoint(24);    // point = 'NNE'\n     *   const point = Dms.compassPoint(24, 1); // point = 'N'\n     */\n    static compassPoint(bearing, precision=3) {\n        if (![ 1, 2, 3 ].includes(Number(precision))) throw new RangeError(`invalid precision ‘${precision}’`);\n        // note precision could be extended to 4 for quarter-winds (eg NbNW), but I think they are little used\n\n        bearing = Dms.wrap360(bearing); // normalise to range 0..360°\n\n        const cardinals = [\n            'N', 'NNE', 'NE', 'ENE',\n            'E', 'ESE', 'SE', 'SSE',\n            'S', 'SSW', 'SW', 'WSW',\n            'W', 'WNW', 'NW', 'NNW' ];\n        const n = 4 * 2**(precision-1); // no of compass points at req’d precision (1=>4, 2=>8, 3=>16)\n        const cardinal = cardinals[Math.round(bearing*n/360)%n * 16/n];\n\n        return cardinal;\n    }\n\n\n    /**\n     * Constrain degrees to range 0..360 (e.g. for bearings); -1 => 359, 361 => 1.\n     *\n     * @private\n     * @param {number} degrees\n     * @returns degrees within range 0..360.\n     */\n    static wrap360(degrees) {\n        if (0<=degrees && degrees<360) return degrees; // avoid rounding due to arithmetic ops if within range\n        return (degrees%360+360) % 360; // sawtooth wave p:360, a:360\n    }\n\n    /**\n     * Constrain degrees to range -180..+180 (e.g. for longitude); -181 => 179, 181 => -179.\n     *\n     * @private\n     * @param {number} degrees\n     * @returns degrees within range -180..+180.\n     */\n    static wrap180(degrees) {\n        if (-180<degrees && degrees<=180) return degrees; // avoid rounding due to arithmetic ops if within range\n        return (degrees+540)%360-180; // sawtooth wave p:180, a:±180\n    }\n\n    /**\n     * Constrain degrees to range -90..+90 (e.g. for latitude); -91 => -89, 91 => 89.\n     *\n     * @private\n     * @param {number} degrees\n     * @returns degrees within range -90..+90.\n     */\n    static wrap90(degrees) {\n        if (-90<=degrees && degrees<=90) return degrees; // avoid rounding due to arithmetic ops if within range\n        return Math.abs((degrees%360 + 270)%360 - 180) - 90; // triangle wave p:360 a:±90 TODO: fix e.g. -315°\n    }\n\n}\n\n\n// Extend Number object with methods to convert between degrees & radians\nNumber.prototype.toRadians = function() { return this * Math.PI / 180; };\nNumber.prototype.toDegrees = function() { return this * 180 / Math.PI; };\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nexport default Dms;\n"]},"metadata":{},"sourceType":"module"}