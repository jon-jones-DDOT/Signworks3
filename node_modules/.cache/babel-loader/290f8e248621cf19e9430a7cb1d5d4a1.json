{"ast":null,"code":"import { mphSigns } from \"../../../SignworksJSON\"; // newCode is the mutcd.code that is being checked signs -  an array of signs on\n// the signpost each sign should have a property called MUTCD that has the info\n// from the sign catalog USE SIGNCODE ATTRIBUTE\n\nexport function MutcdDuplicate(newCode, signs) {\n  var isDupe = \"\";\n\n  for (var i = 0; i < signs.length; i++) {\n    if (signs[i].MUTCD.code === newCode) {\n      isDupe = true;\n    }\n  }\n\n  return isDupe;\n}\nexport function isSpeedLimit(mutt) {\n  mutt = mutt.toUpperCase();\n  var returnObj = {\n    disabled: true,\n    speedLimit: null\n  };\n  var regX = /\\(([^)]+)\\)/;\n  var speedy = mphSigns.find(function (code) {\n    if (code === mutt) {\n      return mutt;\n    }\n  });\n\n  if (speedy) {\n    var match = regX.exec(speedy);\n\n    if (match) {\n      returnObj.speedLimit = match[1];\n    } else {\n      returnObj.disabled = false;\n      returnObj.speedLimit = 0;\n    }\n  }\n\n  return returnObj;\n}\nexport function zoneVerify(edState) {\n  //regex\n  var anc = /[A-G]/;\n  var ward = /[1-8]/;\n  var amp = /[&]/;\n  var ward1 = edState.ward1 ? edState.ward1 : \"\";\n  var ward2 = edState.ward2 ? edState.ward2 : \"\";\n  var anc1 = edState.anc1 ? edState.anc1 : \"\";\n  var anc2 = edState.anc2 ? edState.anc2 : \"\"; //assemble zone\n\n  var zoneValue = ward1 + anc1;\n\n  if (ward2) {\n    zoneValue += \"&\" + ward2 + anc2;\n  } else if (anc2) {\n    // you've got a anc with no ward\n    return false;\n  } //  verify zone with same script as python server side this algorithm is overly\n  // rigorous since unlike the server side, the zone value is constrained by\n  // input controls.  But it should work and might be needed later\n\n\n  if (zoneValue === \"\" || !zoneValue) {\n    // this was an error before , but having an empty value is ok above is an old\n    // comment, might not be \"true\" in 3.0\n    return true;\n  }\n\n  if (zoneValue.length < 1) {\n    return true;\n  }\n\n  if (ward.test(zoneValue[0])) {\n    // we have a ward in first position\n    if (zoneValue.length < 2) {\n      // it was just a single ward\n      return true;\n    }\n\n    if (amp.test(zoneValue[1])) {\n      //single digit ward and ...\n      if (ward.test(zoneValue[2])) {\n        //single digit ward and ward and ...\n        if (zoneValue.length < 4) {\n          //single digit ward and single digit ward and done\n          return true;\n        }\n\n        if (anc.test(zoneValue[3])) {\n          // single digit ward and ward+anc and done\n          return true;\n        } else {\n          //single digit ward and some garbage\n          return false;\n        }\n      }\n    } else if (anc.test(zoneValue[1])) {\n      // ward + anc\n      if (zoneValue.length < 3) {\n        // ward + anc and done\n        return true;\n      } else if (amp.test(zoneValue[2])) {\n        // ward + anc and ...\n        if (zoneValue.length < 4) {\n          // oops, nothing after the ampersand we could just fix it here clip the\n          // ampersand\n          return false;\n        } else if (ward.test(zoneValue[3])) {\n          // ward + anc and ward and ...\n          if (zoneValue.length < 5) {\n            // ward + anc and single digit ward and done\n            return true;\n          } else if (zoneValue.length > 5) {\n            // too many characters  - - shouldn't happen here but check anyway\n            return false;\n          } else if (anc.test(zoneValue[4])) {\n            // ward + anc and ward = anc and done\n            return true;\n          } else {\n            // ward + anc + ward + garbage\n            return false;\n          }\n        } else {\n          // ward + anc + ampersand + garbage\n          return false;\n        }\n      } else {\n        // ward + anc + garbage\n        return false;\n      }\n    } else {\n      //ward + garbage\n      return false;\n    }\n  } else {\n    //garbage from the get go\n    return false;\n  } //should never get here\n\n\n  return false;\n}\n; //gets an individual timeband and makes sure that it is internally consistent\n\nexport function timebandVerify(timeband) {\n  var startDay = timeband.attributes.STARTDAY;\n  var endDay = timeband.attributes.ENDDAY;\n  var startTime = timeband.attributes.STARTTIME;\n  var endTime = timeband.attributes.ENDTIME;\n  var errorArray = []; // check to see if start day is a day of the week (and not ANYTIME or whatever)\n\n  if (startDay < 8) {\n    //normal checks go here make sure end day isn't after start day\n    if (endDay < startDay) {\n      errorArray.push('End day is before start day');\n    } //check end day for appropriate value\n\n\n    if (endDay < 1) {\n      errorArray.push('End day is invalid');\n    } // check starttime and end time for non-zero\n\n\n    if (startTime < 1) {\n      errorArray.push('Start time is invalid');\n    }\n\n    if (endTime < 1) {\n      errorArray.push('End time is invalid');\n    } //make sure end time is after start time\n\n\n    if (endTime < startTime) {\n      errorArray.push('End time is before start time');\n    }\n  } else {//ANYTIME and so forth\n  }\n\n  return errorArray;\n}","map":{"version":3,"sources":["C:\\Projects\\Signworks3\\src\\components\\myModules\\Signs\\SignValidations.js"],"names":["mphSigns","MutcdDuplicate","newCode","signs","isDupe","i","length","MUTCD","code","isSpeedLimit","mutt","toUpperCase","returnObj","disabled","speedLimit","regX","speedy","find","match","exec","zoneVerify","edState","anc","ward","amp","ward1","ward2","anc1","anc2","zoneValue","test","timebandVerify","timeband","startDay","attributes","STARTDAY","endDay","ENDDAY","startTime","STARTTIME","endTime","ENDTIME","errorArray","push"],"mappings":"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","sourcesContent":["import {mphSigns} from \"../../../SignworksJSON\";\r\n\r\n// newCode is the mutcd.code that is being checked signs -  an array of signs on\r\n// the signpost each sign should have a property called MUTCD that has the info\r\n// from the sign catalog USE SIGNCODE ATTRIBUTE\r\nexport function MutcdDuplicate(newCode, signs) {\r\n\r\n    let isDupe = \"\";\r\n    for (let i = 0; i < signs.length; i++) {\r\n        if (signs[i].MUTCD.code === newCode) {\r\n            isDupe = true;\r\n        }\r\n    }\r\n\r\n    return isDupe\r\n}\r\n\r\nexport function isSpeedLimit(mutt) {\r\n\r\n    mutt = mutt.toUpperCase();\r\n\r\n    const returnObj = {\r\n        disabled: true,\r\n        speedLimit: null\r\n    }\r\n    const regX = /\\(([^)]+)\\)/;\r\n    const speedy = mphSigns.find((code) => {\r\n        if (code === mutt) {\r\n            return mutt;\r\n        }\r\n\r\n    })\r\n\r\n   \r\n    if (speedy) {\r\n        const match = regX.exec(speedy)\r\n   \r\n        if (match) {\r\n            returnObj.speedLimit = match[1];\r\n        }\r\n        else{\r\n            returnObj.disabled = false;\r\n            returnObj.speedLimit = 0;\r\n            \r\n        }\r\n    }\r\n\r\n    return returnObj;\r\n}\r\n\r\nexport function zoneVerify(edState) {\r\n\r\n    //regex\r\n    const anc = /[A-G]/\r\n    const ward = /[1-8]/\r\n    const amp = /[&]/\r\n\r\n    const ward1 = edState.ward1\r\n        ? edState.ward1\r\n        : \"\";\r\n    const ward2 = edState.ward2\r\n        ? edState.ward2\r\n        : \"\";\r\n    const anc1 = edState.anc1\r\n        ? edState.anc1\r\n        : \"\";\r\n    const anc2 = edState.anc2\r\n        ? edState.anc2\r\n        : \"\";\r\n\r\n    //assemble zone\r\n    let zoneValue = ward1 + anc1;\r\n\r\n    if (ward2) {\r\n        zoneValue += \"&\" + ward2 + anc2;\r\n    } else if (anc2) {\r\n        // you've got a anc with no ward\r\n        return false;\r\n\r\n    }\r\n\r\n    //  verify zone with same script as python server side this algorithm is overly\r\n    // rigorous since unlike the server side, the zone value is constrained by\r\n    // input controls.  But it should work and might be needed later\r\n\r\n    if (zoneValue === \"\" || !zoneValue) {\r\n        // this was an error before , but having an empty value is ok above is an old\r\n        // comment, might not be \"true\" in 3.0\r\n        return true;\r\n    }\r\n    if (zoneValue.length < 1) {\r\n        return true;\r\n    }\r\n\r\n    if (ward.test(zoneValue[0])) {\r\n        // we have a ward in first position\r\n        if (zoneValue.length < 2) {\r\n            // it was just a single ward\r\n            return true;\r\n        }\r\n        if (amp.test(zoneValue[1])) {\r\n            //single digit ward and ...\r\n            if (ward.test(zoneValue[2])) {\r\n                //single digit ward and ward and ...\r\n                if (zoneValue.length < 4) {\r\n                    //single digit ward and single digit ward and done\r\n                    return true;\r\n                }\r\n                if (anc.test(zoneValue[3])) {\r\n                    // single digit ward and ward+anc and done\r\n                    return true;\r\n                } else {\r\n                    //single digit ward and some garbage\r\n                    return false;\r\n                }\r\n            }\r\n        } else if (anc.test(zoneValue[1])) {\r\n            // ward + anc\r\n            if (zoneValue.length < 3) {\r\n                // ward + anc and done\r\n                return true;\r\n            } else if (amp.test(zoneValue[2])) {\r\n                // ward + anc and ...\r\n                if (zoneValue.length < 4) {\r\n                    // oops, nothing after the ampersand we could just fix it here clip the\r\n                    // ampersand\r\n                    return false;\r\n                } else if (ward.test(zoneValue[3])) {\r\n                    // ward + anc and ward and ...\r\n                    if (zoneValue.length < 5) {\r\n                        // ward + anc and single digit ward and done\r\n                        return true;\r\n                    } else if (zoneValue.length > 5) {\r\n                        // too many characters  - - shouldn't happen here but check anyway\r\n                        return false;\r\n                    } else if (anc.test(zoneValue[4])) {\r\n                        // ward + anc and ward = anc and done\r\n                        return true;\r\n                    } else {\r\n                        // ward + anc + ward + garbage\r\n                        return false;\r\n                    }\r\n                } else {\r\n                    // ward + anc + ampersand + garbage\r\n                    return false;\r\n                }\r\n            } else {\r\n                // ward + anc + garbage\r\n                return false;\r\n            }\r\n        } else {\r\n            //ward + garbage\r\n            return false;\r\n        }\r\n\r\n    } else {\r\n        //garbage from the get go\r\n        return false;\r\n    }\r\n    //should never get here\r\n    return false;\r\n};\r\n\r\n//gets an individual timeband and makes sure that it is internally consistent\r\nexport function timebandVerify(timeband) {\r\n\r\n   const startDay = timeband.attributes.STARTDAY;\r\n    const endDay = timeband.attributes.ENDDAY;\r\n    const startTime = timeband.attributes.STARTTIME;\r\n    const endTime = timeband.attributes.ENDTIME;\r\n  \r\n\r\n    let errorArray = [];\r\n\r\n    \r\n\r\n    // check to see if start day is a day of the week (and not ANYTIME or whatever)\r\n    if (startDay < 8) {\r\n        //normal checks go here make sure end day isn't after start day\r\n        if (endDay < startDay) {\r\n            errorArray.push('End day is before start day');\r\n        }\r\n        //check end day for appropriate value\r\n\r\n        if (endDay < 1) {\r\n            errorArray.push('End day is invalid');\r\n        }\r\n        // check starttime and end time for non-zero\r\n        if (startTime < 1) {\r\n            errorArray.push('Start time is invalid');\r\n        }\r\n        if (endTime < 1) {\r\n            errorArray.push('End time is invalid');\r\n        }\r\n        //make sure end time is after start time\r\n        if (endTime < startTime) {\r\n            errorArray.push('End time is before start time')\r\n        }\r\n\r\n    } else {\r\n        //ANYTIME and so forth\r\n    }\r\n    return errorArray;\r\n}"]},"metadata":{},"sourceType":"module"}