{"ast":null,"code":"import { mphSigns } from \"../../../SignworksJSON\"; // newCode is the mutcd.code that is being checked signs -  an array of signs on\n// the signpost each sign should have a property called MUTCD that has the info\n// from the sign catalog\n//USE SIGNCODE ATTRIBUTE\n\nexport function MutcdDuplicate(newCode, signs) {\n  var isDupe = \"\";\n\n  for (var i = 0; i < signs.length; i++) {\n    if (signs[i].MUTCD.code === newCode) {\n      isDupe = true;\n    }\n  }\n\n  return isDupe;\n}\nexport function isSpeedLimit(mutt) {\n  console.log('mutt :', mutt);\n  mutt = mutt.toUpperCase();\n  var returnObj = {\n    disabled: true,\n    speedLimit: 0\n  };\n  var regX = /\\(([^)]+)\\)/;\n  var speedy = mphSigns.find(function (code) {\n    if (code === mutt) {\n      var match = regX.exec(code);\n      console.log('match', match);\n    } else {}\n  });\n}\nexport function zoneVerify(edState) {\n  //regex\n  var anc = /[A-G]/;\n  var ward = /[1-8]/;\n  var amp = /[&]/;\n  var ward1 = edState.ward1 ? edState.ward1 : \"\";\n  var ward2 = edState.ward2 ? edState.ward2 : \"\";\n  var anc1 = edState.anc1 ? edState.anc1 : \"\";\n  var anc2 = edState.anc2 ? edState.anc2 : \"\"; //assemble zone\n\n  var zoneValue = ward1 + anc1;\n\n  if (ward2) {\n    zoneValue += \"&\" + ward2 + anc2;\n  } else if (anc2) {\n    // you've got a anc with no ward\n    return false;\n  } //  verify zone with same script as python server side this\n  // algorithm is overly rigorous since unlike the server side, the zone value is\n  // constrained by input controls.  But it should work and might be needed later\n\n\n  if (zoneValue === \"\" || !zoneValue) {\n    // this was an error before , but having an empty value is ok above is an old\n    // comment, might not be \"true\" in 3.0\n    return true;\n  }\n\n  if (zoneValue.length < 1) {\n    return true;\n  }\n\n  if (ward.test(zoneValue[0])) {\n    // we have a ward in first position\n    if (zoneValue.length < 2) {\n      // it was just a single ward\n      return true;\n    }\n\n    if (amp.test(zoneValue[1])) {\n      //single digit ward and ...\n      if (ward.test(zoneValue[2])) {\n        //single digit ward and ward and ...\n        if (zoneValue.length < 4) {\n          //single digit ward and single digit ward and done\n          return true;\n        }\n\n        if (anc.test(zoneValue[3])) {\n          // single digit ward and ward+anc and done\n          return true;\n        } else {\n          //single digit ward and some garbage\n          return false;\n        }\n      }\n    } else if (anc.test(zoneValue[1])) {\n      // ward + anc\n      if (zoneValue.length < 3) {\n        // ward + anc and done\n        return true;\n      } else if (amp.test(zoneValue[2])) {\n        // ward + anc and ...\n        if (zoneValue.length < 4) {\n          // oops, nothing after the ampersand we could just fix it here clip the\n          // ampersand\n          return false;\n        } else if (ward.test(zoneValue[3])) {\n          // ward + anc and ward and ...\n          if (zoneValue.length < 5) {\n            // ward + anc and single digit ward and done\n            return true;\n          } else if (zoneValue.length > 5) {\n            // too many characters  - - shouldn't happen here but check anyway\n            return false;\n          } else if (anc.test(zoneValue[4])) {\n            // ward + anc and ward = anc and done\n            return true;\n          } else {\n            // ward + anc + ward + garbage\n            return false;\n          }\n        } else {\n          // ward + anc + ampersand + garbage\n          return false;\n        }\n      } else {\n        // ward + anc + garbage\n        return false;\n      }\n    } else {\n      //ward + garbage\n      return false;\n    }\n  } else {\n    //garbage from the get go\n    return false;\n  } //should never get here\n\n\n  return false;\n}\n; //gets an individual timeband and makes sure that it is internally consistent\n\nexport function timebandVerify(timeband) {\n  var startDay = timeband.attributes.STARTDAY;\n  var endDay = timeband.attributes.ENDDAY;\n  var startTime = timeband.attributes.STARTTIME;\n  var endTime = timeband.attributes.ENDTIME;\n  var errorArray = [];\n  var END_DAY_BEFORE_START_DAY = 1;\n  var END_DAY_INVALID = 2;\n  var START_TIME_INVALID = 4;\n  var END_TIME_INVALID = 8;\n  var END_TIME_BEFORE_START_TIME = 16; // check to see if start day is a day of the week (and not ANYTIME or whatever)\n\n  if (startDay < 8) {\n    //normal checks go here make sure end day isn't after start day\n    if (endDay < startDay) {\n      errorArray.push(END_DAY_BEFORE_START_DAY);\n    } //check end day for appropriate value\n\n\n    if (endDay < 1) {\n      errorArray.push(END_DAY_INVALID);\n    } // check starttime and end time for non-zero\n\n\n    if (startTime < 1) {\n      errorArray.push(START_TIME_INVALID);\n    }\n\n    if (endTime < 1) {\n      errorArray.push(END_TIME_INVALID);\n    } //make sure end time is after start time\n\n\n    if (endTime < startTime) {\n      errorArray.push(END_TIME_BEFORE_START_TIME);\n    }\n  } else {//ANYTIME and so forth\n  }\n}","map":{"version":3,"sources":["C:\\Projects\\Signworks3\\src\\components\\myModules\\Signs\\SignValidations.js"],"names":["mphSigns","MutcdDuplicate","newCode","signs","isDupe","i","length","MUTCD","code","isSpeedLimit","mutt","console","log","toUpperCase","returnObj","disabled","speedLimit","regX","speedy","find","match","exec","zoneVerify","edState","anc","ward","amp","ward1","ward2","anc1","anc2","zoneValue","test","timebandVerify","timeband","startDay","attributes","STARTDAY","endDay","ENDDAY","startTime","STARTTIME","endTime","ENDTIME","errorArray","END_DAY_BEFORE_START_DAY","END_DAY_INVALID","START_TIME_INVALID","END_TIME_INVALID","END_TIME_BEFORE_START_TIME","push"],"mappings":"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","sourcesContent":["import { mphSigns} from \"../../../SignworksJSON\";\r\n\r\n// newCode is the mutcd.code that is being checked signs -  an array of signs on\r\n// the signpost each sign should have a property called MUTCD that has the info\r\n// from the sign catalog\r\n//USE SIGNCODE ATTRIBUTE\r\nexport function MutcdDuplicate(newCode, signs) {\r\n\r\n    let isDupe = \"\";\r\n    for (let i = 0; i < signs.length; i++) {\r\n        if (signs[i].MUTCD.code === newCode) {\r\n            isDupe = true;\r\n        }\r\n    }\r\n\r\n    return isDupe\r\n}\r\n\r\nexport function isSpeedLimit(mutt) {\r\n    console.log('mutt :', mutt);\r\n    mutt = mutt.toUpperCase();\r\n   const returnObj = {disabled:true, speedLimit:0}\r\n const regX = /\\(([^)]+)\\)/;\r\n   const speedy = mphSigns.find((code) => {\r\n\r\n    if (code === mutt) {\r\n        let match = regX.exec(code)\r\n       console.log('match', match)\r\n    }\r\n    else{\r\n        \r\n    }\r\n})\r\n\r\n\r\n  \r\n\r\n    }\r\n\r\nexport function zoneVerify(edState) {\r\n\r\n    //regex\r\n    const anc = /[A-G]/\r\n    const ward = /[1-8]/\r\n    const amp = /[&]/\r\n\r\n    const ward1 = edState.ward1\r\n        ? edState.ward1\r\n        : \"\";\r\n    const ward2 = edState.ward2\r\n        ? edState.ward2\r\n        : \"\";\r\n    const anc1 = edState.anc1\r\n        ? edState.anc1\r\n        : \"\";\r\n    const anc2 = edState.anc2\r\n        ? edState.anc2\r\n        : \"\";\r\n\r\n    //assemble zone\r\n    let zoneValue = ward1 + anc1;\r\n\r\n    if (ward2) {\r\n        zoneValue += \"&\" + ward2 + anc2;\r\n    } else if (anc2) {\r\n        // you've got a anc with no ward\r\n        return false;\r\n\r\n    }\r\n\r\n    //  verify zone with same script as python server side this\r\n    // algorithm is overly rigorous since unlike the server side, the zone value is\r\n    // constrained by input controls.  But it should work and might be needed later\r\n\r\n    if (zoneValue === \"\" || !zoneValue) {\r\n        // this was an error before , but having an empty value is ok above is an old\r\n        // comment, might not be \"true\" in 3.0\r\n        return true;\r\n    }\r\n    if (zoneValue.length < 1) {\r\n        return true;\r\n    }\r\n\r\n    if (ward.test(zoneValue[0])) {\r\n        // we have a ward in first position\r\n        if (zoneValue.length < 2) {\r\n            // it was just a single ward\r\n            return true;\r\n        }\r\n        if (amp.test(zoneValue[1])) {\r\n            //single digit ward and ...\r\n            if (ward.test(zoneValue[2])) {\r\n                //single digit ward and ward and ...\r\n                if (zoneValue.length < 4) {\r\n                    //single digit ward and single digit ward and done\r\n                    return true;\r\n                }\r\n                if (anc.test(zoneValue[3])) {\r\n                    // single digit ward and ward+anc and done\r\n                    return true;\r\n                } else {\r\n                    //single digit ward and some garbage\r\n                    return false;\r\n                }\r\n            }\r\n        } else if (anc.test(zoneValue[1])) {\r\n            // ward + anc\r\n            if (zoneValue.length < 3) {\r\n                // ward + anc and done\r\n                return true;\r\n            } else if (amp.test(zoneValue[2])) {\r\n                // ward + anc and ...\r\n                if (zoneValue.length < 4) {\r\n                    // oops, nothing after the ampersand we could just fix it here clip the\r\n                    // ampersand\r\n                    return false;\r\n                } else if (ward.test(zoneValue[3])) {\r\n                    // ward + anc and ward and ...\r\n                    if (zoneValue.length < 5) {\r\n                        // ward + anc and single digit ward and done\r\n                        return true;\r\n                    } else if (zoneValue.length > 5) {\r\n                        // too many characters  - - shouldn't happen here but check anyway\r\n                        return false;\r\n                    } else if (anc.test(zoneValue[4])) {\r\n                        // ward + anc and ward = anc and done\r\n                        return true;\r\n                    } else {\r\n                        // ward + anc + ward + garbage\r\n                        return false;\r\n                    }\r\n                } else {\r\n                    // ward + anc + ampersand + garbage\r\n                    return false;\r\n                }\r\n            } else {\r\n                // ward + anc + garbage\r\n                return false;\r\n            }\r\n        } else {\r\n            //ward + garbage\r\n            return false;\r\n        }\r\n\r\n    } else {\r\n        //garbage from the get go\r\n        return false;\r\n    }\r\n    //should never get here\r\n    return false;\r\n};\r\n\r\n//gets an individual timeband and makes sure that it is internally consistent\r\nexport function timebandVerify(timeband) {\r\n\r\n    const startDay = timeband.attributes.STARTDAY;\r\n    const endDay = timeband.attributes.ENDDAY;\r\n    const startTime = timeband.attributes.STARTTIME;\r\n    const endTime = timeband.attributes.ENDTIME;\r\n\r\n\r\n    let errorArray = [];\r\n\r\n    const END_DAY_BEFORE_START_DAY = 1;\r\n    const END_DAY_INVALID = 2;\r\n    const START_TIME_INVALID = 4;\r\n    const END_TIME_INVALID = 8;\r\n    const END_TIME_BEFORE_START_TIME = 16;\r\n\r\n    // check to see if start day is a day of the week (and not ANYTIME or whatever)\r\n    if (startDay < 8) {\r\n        //normal checks go here make sure end day isn't after start day\r\n        if (endDay < startDay) {\r\n            errorArray.push(END_DAY_BEFORE_START_DAY);\r\n        }\r\n        //check end day for appropriate value\r\n\r\n        if (endDay < 1) {\r\n            errorArray.push(END_DAY_INVALID);\r\n        }\r\n        // check starttime and end time for non-zero\r\n        if (startTime < 1) {\r\n            errorArray.push(START_TIME_INVALID);\r\n        }\r\n        if (endTime < 1) {\r\n            errorArray.push(END_TIME_INVALID);\r\n        }\r\n        //make sure end time is after start time\r\n        if(endTime < startTime){\r\n            errorArray.push(END_TIME_BEFORE_START_TIME)\r\n        }\r\n\r\n\r\n    } else {\r\n        //ANYTIME and so forth\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}