{"ast":null,"code":"import _slicedToArray from \"C:\\\\Projects\\\\Signworks3\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport { loadModules } from 'esri-loader';\n\nvar err = function err(e) {\n  console.log('an error occurred in JSAPI  ' + e.message);\n};\n\nexport function getSupportById(args) {\n  var id = args[0];\n  var layer = args[1];\n  loadModules([\"esri/tasks/support/Query\"]).then(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 1),\n        Query = _ref2[0];\n\n    var query = new Query();\n    query.where = \"OBJECTID = \" + id;\n    query.outFields = [\"*\"];\n    query.returnGeometry = true;\n    layer.queryFeatures(query).then(function (results) {\n      if (results.features.length > 0) {\n        return results.features[0];\n      } else {\n        alert('support was not retrieved');\n      }\n    }, err);\n  }).catch(function (err) {\n    // handle any errors\n    console.error(err);\n  });\n}\nexport function getSupportByExtent(args) {\n  return new Promise(function (resolve, reject) {\n    var extent = args[0];\n    var supportLayer = args[1];\n    loadModules([\"esri/tasks/support/Query\"]).then(function (_ref3) {\n      var _ref4 = _slicedToArray(_ref3, 1),\n          Query = _ref4[0];\n\n      var query = new Query();\n      query.geometry = extent;\n      query.outFields = [\"*\"];\n      query.returnGeometry = true;\n      supportLayer.queryFeatures(query).then(function (resp) {\n        return resolve(resp);\n      }, function (error) {\n        return reject(error);\n      });\n    });\n  });\n}\nexport function getCodedValues(layer, fieldName, filter, callback) {\n  //       var layerMetadata = layer.toJson();      var fields =\n  // layerMetadata.layerDefinition.fields;\n  var url = layer.url + \"/\" + layer.layerId + \"?f=pjson\";\n  var fields = null;\n  var data = this;\n  esriRequest(url, {}).then(function (results) {\n    fields = results.data.fields;\n    var field = null;\n\n    for (var i = 0; i < fields.length; i++) {\n      if (fields[i].name === fieldName) {\n        field = fields[i];\n        break;\n      }\n    }\n\n    if (field === null) return null;\n\n    if (field.domain != null) {\n      //need an object that can handle an undefined value as a parameter\n      var BetterCodedValue = {};\n      BetterCodedValue._codedValue = field.domain.codedValues;\n\n      if (filter) {\n        BetterCodedValue._codedValue = BetterCodedValue._codedValue.filter(filter);\n      }\n\n      BetterCodedValue.name = function (index) {\n        try {\n          for (var i = 0; i < this._codedValue.length; i++) {\n            if (this._codedValue[i].code == index) {\n              return this._codedValue[i].name;\n            }\n          }\n\n          return \"\";\n        } catch (err) {\n          alert(err.message);\n        }\n      };\n\n      callback(data, field, BetterCodedValue);\n    }\n  }, this.err);\n}\nexport function pointToExtent(view, point, toleranceInPixel, callback) {\n  loadModules([\"esri/geometry/Extent\"]).then(function (_ref5) {\n    var _ref6 = _slicedToArray(_ref5, 1),\n        Extent = _ref6[0];\n\n    //calculate map coords represented per pixel\n    var pixelWidth = view.extent.width / view.width; //calculate map coords for tolerance in pixel\n\n    var toleraceInMapCoords = toleranceInPixel * pixelWidth; //calculate & return computed extent\n\n    callback(new Extent(point.x - toleraceInMapCoords, point.y - toleraceInMapCoords, point.x + toleraceInMapCoords, point.y + toleraceInMapCoords, view.spatialReference));\n  });\n}","map":{"version":3,"sources":["C:\\Projects\\Signworks3\\src\\utils\\JSAPI.js"],"names":["loadModules","err","e","console","log","message","getSupportById","args","id","layer","then","Query","query","where","outFields","returnGeometry","queryFeatures","results","features","length","alert","catch","error","getSupportByExtent","Promise","resolve","reject","extent","supportLayer","geometry","resp","getCodedValues","fieldName","filter","callback","url","layerId","fields","data","esriRequest","field","i","name","domain","BetterCodedValue","_codedValue","codedValues","index","code","pointToExtent","view","point","toleranceInPixel","Extent","pixelWidth","width","toleraceInMapCoords","x","y","spatialReference"],"mappings":"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","sourcesContent":["import {loadModules} from 'esri-loader';\r\n\r\nconst err = (e) => {\r\n    console.log('an error occurred in JSAPI  ' + e.message)\r\n}\r\n\r\nexport function getSupportById(args) {\r\n    const id = args[0];\r\n    const layer = args[1];\r\n\r\n    loadModules([\"esri/tasks/support/Query\"]).then(([Query]) => {\r\n        let query = new Query();\r\n        query.where = \"OBJECTID = \" + id;\r\n        query.outFields = [\"*\"];\r\n        query.returnGeometry = true;\r\n\r\n        layer\r\n            .queryFeatures(query)\r\n            .then(function (results) {\r\n\r\n                if (results.features.length > 0) {\r\n\r\n                    return results.features[0];\r\n                } else {\r\n                    alert('support was not retrieved')\r\n                }\r\n            }, err);\r\n\r\n    }).catch(err => {\r\n        // handle any errors\r\n        console.error(err);\r\n    });\r\n}\r\n\r\nexport function getSupportByExtent(args) {\r\n    return new Promise((resolve, reject) => {\r\n\r\n        const extent = args[0];\r\n\r\n        const supportLayer = args[1];\r\n\r\n        loadModules([\"esri/tasks/support/Query\"]).then(([Query]) => {\r\n\r\n            let query = new Query();\r\n            query.geometry = extent;\r\n            query.outFields = [\"*\"];\r\n            query.returnGeometry = true;\r\n\r\n            supportLayer\r\n                .queryFeatures(query)\r\n                .then(resp => resolve(resp), error => reject(error));\r\n        });\r\n\r\n    })\r\n}\r\n\r\nexport function getCodedValues(layer, fieldName, filter, callback) {\r\n\r\n    //       var layerMetadata = layer.toJson();      var fields =\r\n    // layerMetadata.layerDefinition.fields;\r\n    let url = layer.url + \"/\" + layer.layerId + \"?f=pjson\";\r\n    let fields = null;\r\n    let data = this;\r\n    esriRequest(url, {}).then(function (results) {\r\n        fields = results.data.fields;\r\n        let field = null;\r\n        for (var i = 0; i < fields.length; i++) {\r\n\r\n            if (fields[i].name === fieldName) {\r\n\r\n                field = fields[i];\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (field === null) \r\n            return null;\r\n        if (field.domain != null) {\r\n\r\n            //need an object that can handle an undefined value as a parameter\r\n            var BetterCodedValue = {};\r\n            BetterCodedValue._codedValue = field.domain.codedValues;\r\n\r\n            if (filter) {\r\n                BetterCodedValue._codedValue = BetterCodedValue\r\n                    ._codedValue\r\n                    .filter(filter);\r\n            }\r\n\r\n            BetterCodedValue.name = function (index) {\r\n\r\n                try {\r\n\r\n                    for (var i = 0; i < this._codedValue.length; i++) {\r\n\r\n                        if (this._codedValue[i].code == index) {\r\n                            return this._codedValue[i].name;\r\n                        }\r\n                    }\r\n\r\n                    return \"\";\r\n                } catch (err) {\r\n                    alert(err.message);\r\n                }\r\n            };\r\n\r\n            callback(data, field, BetterCodedValue);\r\n\r\n        }\r\n\r\n    }, this.err);\r\n}\r\n\r\nexport function pointToExtent(view, point, toleranceInPixel, callback) {\r\n\r\n    loadModules([\"esri/geometry/Extent\"]).then(([Extent]) => {\r\n\r\n        //calculate map coords represented per pixel\r\n        let pixelWidth = view.extent.width / view.width;\r\n\r\n        //calculate map coords for tolerance in pixel\r\n        let toleraceInMapCoords = toleranceInPixel * pixelWidth;\r\n        //calculate & return computed extent\r\n\r\n        callback(new Extent(point.x - toleraceInMapCoords, point.y - toleraceInMapCoords, point.x + toleraceInMapCoords, point.y + toleraceInMapCoords, view.spatialReference))\r\n\r\n    })\r\n\r\n}"]},"metadata":{},"sourceType":"module"}