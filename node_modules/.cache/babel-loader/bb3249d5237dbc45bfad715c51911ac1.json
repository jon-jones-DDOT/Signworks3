{"ast":null,"code":"import _slicedToArray from \"C:\\\\Projects\\\\Signworks3\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"C:\\\\Projects\\\\Signworks3\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Projects\\\\Signworks3\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n/* Latitude/longitude spherical geodesy tools                         (c) Chris Veness 2002-2019  */\n\n/*                                                                                   MIT Licence  */\n\n/* www.movable-type.co.uk/scripts/latlong.html                                                    */\n\n/* www.movable-type.co.uk/scripts/geodesy-library.html#latlon-spherical                           */\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\nimport Dms from './dms.js';\nvar π = Math.PI;\n/**\n * Library of geodesy functions for operations on a spherical earth model.\n *\n * Includes distances, bearings, destinations, etc, for both great circle paths and rhumb lines,\n * and other related functions.\n *\n * All calculations are done using simple spherical trigonometric formulae.\n *\n * @module latlon-spherical\n */\n// note greek letters (e.g. φ, λ, θ) are used for angles in radians to distinguish from angles in\n// degrees (e.g. lat, lon, brng)\n\n/* LatLonSpherical - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n/**\n * Latitude/longitude points on a spherical model earth, and methods for calculating distances,\n * bearings, destinations, etc on (orthodromic) great-circle paths and (loxodromic) rhumb lines.\n */\n\nvar LatLonSpherical =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates a latitude/longitude point on the earth’s surface, using a spherical model earth.\n   *\n   * @param  {number} lat - Latitude (in degrees).\n   * @param  {number} lon - Longitude (in degrees).\n   * @throws {TypeError} Invalid lat/lon.\n   *\n   * @example\n   *   import LatLon from '/js/geodesy/latlon-spherical.js';\n   *   const p = new LatLon(52.205, 0.119);\n   */\n  function LatLonSpherical(lat, lon) {\n    _classCallCheck(this, LatLonSpherical);\n\n    if (isNaN(lat)) throw new TypeError(\"invalid lat \\u2018\".concat(lat, \"\\u2019\"));\n    if (isNaN(lon)) throw new TypeError(\"invalid lon \\u2018\".concat(lon, \"\\u2019\"));\n    this._lat = Dms.wrap90(lat);\n    this._lon = Dms.wrap180(lon);\n  }\n  /**\n   * Latitude in degrees north from equator (including aliases lat, latitude): can be set as\n   * numeric or hexagesimal (deg-min-sec); returned as numeric.\n   */\n\n\n  _createClass(LatLonSpherical, [{\n    key: \"distanceTo\",\n\n    /**\n     * Returns the distance along the surface of the earth from ‘this’ point to destination point.\n     *\n     * Uses haversine formula: a = sin²(Δφ/2) + cosφ1·cosφ2 · sin²(Δλ/2); d = 2 · atan2(√a, √(a-1)).\n     *\n     * @param   {LatLon} point - Latitude/longitude of destination point.\n     * @param   {number} [radius=6371e3] - Radius of earth (defaults to mean radius in metres).\n     * @returns {number} Distance between this point and destination point, in same units as radius.\n     * @throws  {TypeError} Invalid radius.\n     *\n     * @example\n     *   const p1 = new LatLon(52.205, 0.119);\n     *   const p2 = new LatLon(48.857, 2.351);\n     *   const d = p1.distanceTo(p2);       // 404.3×10³ m\n     *   const m = p1.distanceTo(p2, 3959); // 251.2 miles\n     */\n    value: function distanceTo(point) {\n      var radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 6371e3;\n      if (!(point instanceof LatLonSpherical)) point = LatLonSpherical.parse(point); // allow literal forms\n\n      if (isNaN(radius)) throw new TypeError(\"invalid radius \\u2018\".concat(radius, \"\\u2019\")); // a = sin²(Δφ/2) + cos(φ1)⋅cos(φ2)⋅sin²(Δλ/2)\n      // δ = 2·atan2(√(a), √(1−a))\n      // see mathforum.org/library/drmath/view/51879.html for derivation\n\n      var R = radius;\n      var φ1 = this.lat.toRadians(),\n          λ1 = this.lon.toRadians();\n      var φ2 = point.lat.toRadians(),\n          λ2 = point.lon.toRadians();\n      var Δφ = φ2 - φ1;\n      var Δλ = λ2 - λ1;\n      var a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);\n      var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n      var d = R * c;\n      return d;\n    }\n    /**\n     * Returns the initial bearing from ‘this’ point to destination point.\n     *\n     * @param   {LatLon} point - Latitude/longitude of destination point.\n     * @returns {number} Initial bearing in degrees from north (0°..360°).\n     *\n     * @example\n     *   const p1 = new LatLon(52.205, 0.119);\n     *   const p2 = new LatLon(48.857, 2.351);\n     *   const b1 = p1.initialBearingTo(p2); // 156.2°\n     */\n\n  }, {\n    key: \"initialBearingTo\",\n    value: function initialBearingTo(point) {\n      if (!(point instanceof LatLonSpherical)) point = LatLonSpherical.parse(point); // allow literal forms\n\n      if (this.equals(point)) return NaN; // coincident points\n      // tanθ = sinΔλ⋅cosφ2 / cosφ1⋅sinφ2 − sinφ1⋅cosφ2⋅cosΔλ\n      // see mathforum.org/library/drmath/view/55417.html for derivation\n\n      var φ1 = this.lat.toRadians();\n      var φ2 = point.lat.toRadians();\n      var Δλ = (point.lon - this.lon).toRadians();\n      var x = Math.cos(φ1) * Math.sin(φ2) - Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);\n      var y = Math.sin(Δλ) * Math.cos(φ2);\n      var θ = Math.atan2(y, x);\n      var bearing = θ.toDegrees();\n      return Dms.wrap360(bearing);\n    }\n    /**\n     * Returns final bearing arriving at destination point from ‘this’ point; the final bearing will\n     * differ from the initial bearing by varying degrees according to distance and latitude.\n     *\n     * @param   {LatLon} point - Latitude/longitude of destination point.\n     * @returns {number} Final bearing in degrees from north (0°..360°).\n     *\n     * @example\n     *   const p1 = new LatLon(52.205, 0.119);\n     *   const p2 = new LatLon(48.857, 2.351);\n     *   const b2 = p1.finalBearingTo(p2); // 157.9°\n     */\n\n  }, {\n    key: \"finalBearingTo\",\n    value: function finalBearingTo(point) {\n      if (!(point instanceof LatLonSpherical)) point = LatLonSpherical.parse(point); // allow literal forms\n      // get initial bearing from destination point to this point & reverse it by adding 180°\n\n      var bearing = point.initialBearingTo(this) + 180;\n      return Dms.wrap360(bearing);\n    }\n    /**\n     * Returns the midpoint between ‘this’ point and destination point.\n     *\n     * @param   {LatLon} point - Latitude/longitude of destination point.\n     * @returns {LatLon} Midpoint between this point and destination point.\n     *\n     * @example\n     *   const p1 = new LatLon(52.205, 0.119);\n     *   const p2 = new LatLon(48.857, 2.351);\n     *   const pMid = p1.midpointTo(p2); // 50.5363°N, 001.2746°E\n     */\n\n  }, {\n    key: \"midpointTo\",\n    value: function midpointTo(point) {\n      if (!(point instanceof LatLonSpherical)) point = LatLonSpherical.parse(point); // allow literal forms\n      // φm = atan2( sinφ1 + sinφ2, √( (cosφ1 + cosφ2⋅cosΔλ)² + cos²φ2⋅sin²Δλ ) )\n      // λm = λ1 + atan2(cosφ2⋅sinΔλ, cosφ1 + cosφ2⋅cosΔλ)\n      // midpoint is sum of vectors to two points: mathforum.org/library/drmath/view/51822.html\n\n      var φ1 = this.lat.toRadians();\n      var λ1 = this.lon.toRadians();\n      var φ2 = point.lat.toRadians();\n      var Δλ = (point.lon - this.lon).toRadians(); // get cartesian coordinates for the two points\n\n      var A = {\n        x: Math.cos(φ1),\n        y: 0,\n        z: Math.sin(φ1)\n      }; // place point A on prime meridian y=0\n\n      var B = {\n        x: Math.cos(φ2) * Math.cos(Δλ),\n        y: Math.cos(φ2) * Math.sin(Δλ),\n        z: Math.sin(φ2)\n      }; // vector to midpoint is sum of vectors to two points (no need to normalise)\n\n      var C = {\n        x: A.x + B.x,\n        y: A.y + B.y,\n        z: A.z + B.z\n      };\n      var φm = Math.atan2(C.z, Math.sqrt(C.x * C.x + C.y * C.y));\n      var λm = λ1 + Math.atan2(C.y, C.x);\n      var lat = φm.toDegrees();\n      var lon = λm.toDegrees();\n      return new LatLonSpherical(lat, lon);\n    }\n    /**\n     * Returns the point at given fraction between ‘this’ point and given point.\n     *\n     * @param   {LatLon} point - Latitude/longitude of destination point.\n     * @param   {number} fraction - Fraction between the two points (0 = this point, 1 = specified point).\n     * @returns {LatLon} Intermediate point between this point and destination point.\n     *\n     * @example\n     *   const p1 = new LatLon(52.205, 0.119);\n     *   const p2 = new LatLon(48.857, 2.351);\n     *   const pInt = p1.intermediatePointTo(p2, 0.25); // 51.3721°N, 000.7073°E\n     */\n\n  }, {\n    key: \"intermediatePointTo\",\n    value: function intermediatePointTo(point, fraction) {\n      if (!(point instanceof LatLonSpherical)) point = LatLonSpherical.parse(point); // allow literal forms\n\n      if (this.equals(point)) return new LatLonSpherical(this.lat, this.lon); // coincident points\n\n      var φ1 = this.lat.toRadians(),\n          λ1 = this.lon.toRadians();\n      var φ2 = point.lat.toRadians(),\n          λ2 = point.lon.toRadians(); // distance between points\n\n      var Δφ = φ2 - φ1;\n      var Δλ = λ2 - λ1;\n      var a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);\n      var δ = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n      var A = Math.sin((1 - fraction) * δ) / Math.sin(δ);\n      var B = Math.sin(fraction * δ) / Math.sin(δ);\n      var x = A * Math.cos(φ1) * Math.cos(λ1) + B * Math.cos(φ2) * Math.cos(λ2);\n      var y = A * Math.cos(φ1) * Math.sin(λ1) + B * Math.cos(φ2) * Math.sin(λ2);\n      var z = A * Math.sin(φ1) + B * Math.sin(φ2);\n      var φ3 = Math.atan2(z, Math.sqrt(x * x + y * y));\n      var λ3 = Math.atan2(y, x);\n      var lat = φ3.toDegrees();\n      var lon = λ3.toDegrees();\n      return new LatLonSpherical(lat, lon);\n    }\n    /**\n     * Returns the destination point from ‘this’ point having travelled the given distance on the\n     * given initial bearing (bearing normally varies around path followed).\n     *\n     * @param   {number} distance - Distance travelled, in same units as earth radius (default: metres).\n     * @param   {number} bearing - Initial bearing in degrees from north.\n     * @param   {number} [radius=6371e3] - (Mean) radius of earth (defaults to radius in metres).\n     * @returns {LatLon} Destination point.\n     *\n     * @example\n     *   const p1 = new LatLon(51.47788, -0.00147);\n     *   const p2 = p1.destinationPoint(7794, 300.7); // 51.5136°N, 000.0983°W\n     */\n\n  }, {\n    key: \"destinationPoint\",\n    value: function destinationPoint(distance, bearing) {\n      var radius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 6371e3;\n      // sinφ2 = sinφ1⋅cosδ + cosφ1⋅sinδ⋅cosθ\n      // tanΔλ = sinθ⋅sinδ⋅cosφ1 / cosδ−sinφ1⋅sinφ2\n      // see mathforum.org/library/drmath/view/52049.html for derivation\n      var δ = distance / radius; // angular distance in radians\n\n      var θ = Number(bearing).toRadians();\n      var φ1 = this.lat.toRadians(),\n          λ1 = this.lon.toRadians();\n      var sinφ2 = Math.sin(φ1) * Math.cos(δ) + Math.cos(φ1) * Math.sin(δ) * Math.cos(θ);\n      var φ2 = Math.asin(sinφ2);\n      var y = Math.sin(θ) * Math.sin(δ) * Math.cos(φ1);\n      var x = Math.cos(δ) - Math.sin(φ1) * sinφ2;\n      var λ2 = λ1 + Math.atan2(y, x);\n      var lat = φ2.toDegrees();\n      var lon = λ2.toDegrees();\n      return new LatLonSpherical(lat, lon);\n    }\n    /**\n     * Returns the point of intersection of two paths defined by point and bearing.\n     *\n     * @param   {LatLon}      p1 - First point.\n     * @param   {number}      brng1 - Initial bearing from first point.\n     * @param   {LatLon}      p2 - Second point.\n     * @param   {number}      brng2 - Initial bearing from second point.\n     * @returns {LatLon|null} Destination point (null if no unique intersection defined).\n     *\n     * @example\n     *   const p1 = new LatLon(51.8853, 0.2545), brng1 = 108.547;\n     *   const p2 = new LatLon(49.0034, 2.5735), brng2 =  32.435;\n     *   const pInt = LatLon.intersection(p1, brng1, p2, brng2); // 50.9078°N, 004.5084°E\n     */\n\n  }, {\n    key: \"crossTrackDistanceTo\",\n\n    /**\n     * Returns (signed) distance from ‘this’ point to great circle defined by start-point and\n     * end-point.\n     *\n     * @param   {LatLon} pathStart - Start point of great circle path.\n     * @param   {LatLon} pathEnd - End point of great circle path.\n     * @param   {number} [radius=6371e3] - (Mean) radius of earth (defaults to radius in metres).\n     * @returns {number} Distance to great circle (-ve if to left, +ve if to right of path).\n     *\n     * @example\n     *   const pCurrent = new LatLon(53.2611, -0.7972);\n     *   const p1 = new LatLon(53.3206, -1.7297);\n     *   const p2 = new LatLon(53.1887, 0.1334);\n     *   const d = pCurrent.crossTrackDistanceTo(p1, p2);  // -307.5 m\n     */\n    value: function crossTrackDistanceTo(pathStart, pathEnd) {\n      var radius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 6371e3;\n      if (!(pathStart instanceof LatLonSpherical)) pathStart = LatLonSpherical.parse(pathStart); // allow literal forms\n\n      if (!(pathEnd instanceof LatLonSpherical)) pathEnd = LatLonSpherical.parse(pathEnd); // allow literal forms\n\n      var R = radius;\n      var δ13 = pathStart.distanceTo(this, R) / R;\n      var θ13 = pathStart.initialBearingTo(this).toRadians();\n      var θ12 = pathStart.initialBearingTo(pathEnd).toRadians();\n      var δxt = Math.asin(Math.sin(δ13) * Math.sin(θ13 - θ12));\n      return δxt * R;\n    }\n    /**\n     * Returns how far ‘this’ point is along a path from from start-point, heading towards end-point.\n     * That is, if a perpendicular is drawn from ‘this’ point to the (great circle) path, the\n     * along-track distance is the distance from the start point to where the perpendicular crosses\n     * the path.\n     *\n     * @param   {LatLon} pathStart - Start point of great circle path.\n     * @param   {LatLon} pathEnd - End point of great circle path.\n     * @param   {number} [radius=6371e3] - (Mean) radius of earth (defaults to radius in metres).\n     * @returns {number} Distance along great circle to point nearest ‘this’ point.\n     *\n     * @example\n     *   const pCurrent = new LatLon(53.2611, -0.7972);\n     *   const p1 = new LatLon(53.3206, -1.7297);\n     *   const p2 = new LatLon(53.1887,  0.1334);\n     *   const d = pCurrent.alongTrackDistanceTo(p1, p2);  // 62.331 km\n     */\n\n  }, {\n    key: \"alongTrackDistanceTo\",\n    value: function alongTrackDistanceTo(pathStart, pathEnd) {\n      var radius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 6371e3;\n      if (!(pathStart instanceof LatLonSpherical)) pathStart = LatLonSpherical.parse(pathStart); // allow literal forms\n\n      if (!(pathEnd instanceof LatLonSpherical)) pathEnd = LatLonSpherical.parse(pathEnd); // allow literal forms\n\n      var R = radius;\n      var δ13 = pathStart.distanceTo(this, R) / R;\n      var θ13 = pathStart.initialBearingTo(this).toRadians();\n      var θ12 = pathStart.initialBearingTo(pathEnd).toRadians();\n      var δxt = Math.asin(Math.sin(δ13) * Math.sin(θ13 - θ12));\n      var δat = Math.acos(Math.cos(δ13) / Math.abs(Math.cos(δxt)));\n      return δat * Math.sign(Math.cos(θ12 - θ13)) * R;\n    }\n    /**\n     * Returns maximum latitude reached when travelling on a great circle on given bearing from\n     * ‘this’ point (‘Clairaut’s formula’). Negate the result for the minimum latitude (in the\n     * southern hemisphere).\n     *\n     * The maximum latitude is independent of longitude; it will be the same for all points on a\n     * given latitude.\n     *\n     * @param   {number} bearing - Initial bearing.\n     * @returns {number} Maximum latitude reached.\n     */\n\n  }, {\n    key: \"maxLatitude\",\n    value: function maxLatitude(bearing) {\n      var θ = Number(bearing).toRadians();\n      var φ = this.lat.toRadians();\n      var φMax = Math.acos(Math.abs(Math.sin(θ) * Math.cos(φ)));\n      return φMax.toDegrees();\n    }\n    /**\n     * Returns the pair of meridians at which a great circle defined by two points crosses the given\n     * latitude. If the great circle doesn't reach the given latitude, null is returned.\n     *\n     * @param   {LatLon}      point1 - First point defining great circle.\n     * @param   {LatLon}      point2 - Second point defining great circle.\n     * @param   {number}      latitude - Latitude crossings are to be determined for.\n     * @returns {Object|null} Object containing { lon1, lon2 } or null if given latitude not reached.\n     */\n\n  }, {\n    key: \"rhumbDistanceTo\",\n\n    /* Rhumb - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n    /**\n     * Returns the distance travelling from ‘this’ point to destination point along a rhumb line.\n     *\n     * @param   {LatLon} point - Latitude/longitude of destination point.\n     * @param   {number} [radius=6371e3] - (Mean) radius of earth (defaults to radius in metres).\n     * @returns {number} Distance in km between this point and destination point (same units as radius).\n     *\n     * @example\n     *   const p1 = new LatLon(51.127, 1.338);\n     *   const p2 = new LatLon(50.964, 1.853);\n     *   const d = p1.distanceTo(p2); //  40.31 km\n     */\n    value: function rhumbDistanceTo(point) {\n      var radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 6371e3;\n      if (!(point instanceof LatLonSpherical)) point = LatLonSpherical.parse(point); // allow literal forms\n      // see www.edwilliams.org/avform.htm#Rhumb\n\n      var R = radius;\n      var φ1 = this.lat.toRadians();\n      var φ2 = point.lat.toRadians();\n      var Δφ = φ2 - φ1;\n      var Δλ = Math.abs(point.lon - this.lon).toRadians(); // if dLon over 180° take shorter rhumb line across the anti-meridian:\n\n      if (Math.abs(Δλ) > π) Δλ = Δλ > 0 ? -(2 * π - Δλ) : 2 * π + Δλ; // on Mercator projection, longitude distances shrink by latitude; q is the 'stretch factor'\n      // q becomes ill-conditioned along E-W line (0/0); use empirical tolerance to avoid it\n\n      var Δψ = Math.log(Math.tan(φ2 / 2 + π / 4) / Math.tan(φ1 / 2 + π / 4));\n      var q = Math.abs(Δψ) > 10e-12 ? Δφ / Δψ : Math.cos(φ1); // distance is pythagoras on 'stretched' Mercator projection, √(Δφ² + q²·Δλ²)\n\n      var δ = Math.sqrt(Δφ * Δφ + q * q * Δλ * Δλ); // angular distance in radians\n\n      var d = δ * R;\n      return d;\n    }\n    /**\n     * Returns the bearing from ‘this’ point to destination point along a rhumb line.\n     *\n     * @param   {LatLon}    point - Latitude/longitude of destination point.\n     * @returns {number}    Bearing in degrees from north.\n     *\n     * @example\n     *   const p1 = new LatLon(51.127, 1.338);\n     *   const p2 = new LatLon(50.964, 1.853);\n     *   const d = p1.rhumbBearingTo(p2); // 116.7°\n     */\n\n  }, {\n    key: \"rhumbBearingTo\",\n    value: function rhumbBearingTo(point) {\n      if (!(point instanceof LatLonSpherical)) point = LatLonSpherical.parse(point); // allow literal forms\n\n      if (this.equals(point)) return NaN; // coincident points\n\n      var φ1 = this.lat.toRadians();\n      var φ2 = point.lat.toRadians();\n      var Δλ = (point.lon - this.lon).toRadians(); // if dLon over 180° take shorter rhumb line across the anti-meridian:\n\n      if (Math.abs(Δλ) > π) Δλ = Δλ > 0 ? -(2 * π - Δλ) : 2 * π + Δλ;\n      var Δψ = Math.log(Math.tan(φ2 / 2 + π / 4) / Math.tan(φ1 / 2 + π / 4));\n      var θ = Math.atan2(Δλ, Δψ);\n      var bearing = θ.toDegrees();\n      return Dms.wrap360(bearing);\n    }\n    /**\n     * Returns the destination point having travelled along a rhumb line from ‘this’ point the given\n     * distance on the given bearing.\n     *\n     * @param   {number} distance - Distance travelled, in same units as earth radius (default: metres).\n     * @param   {number} bearing - Bearing in degrees from north.\n     * @param   {number} [radius=6371e3] - (Mean) radius of earth (defaults to radius in metres).\n     * @returns {LatLon} Destination point.\n     *\n     * @example\n     *   const p1 = new LatLon(51.127, 1.338);\n     *   const p2 = p1.rhumbDestinationPoint(40300, 116.7); // 50.9642°N, 001.8530°E\n     */\n\n  }, {\n    key: \"rhumbDestinationPoint\",\n    value: function rhumbDestinationPoint(distance, bearing) {\n      var radius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 6371e3;\n      var φ1 = this.lat.toRadians(),\n          λ1 = this.lon.toRadians();\n      var θ = Number(bearing).toRadians();\n      var δ = distance / radius; // angular distance in radians\n\n      var Δφ = δ * Math.cos(θ);\n      var φ2 = φ1 + Δφ; // check for some daft bugger going past the pole, normalise latitude if so\n\n      if (Math.abs(φ2) > π / 2) φ2 = φ2 > 0 ? π - φ2 : -π - φ2;\n      var Δψ = Math.log(Math.tan(φ2 / 2 + π / 4) / Math.tan(φ1 / 2 + π / 4));\n      var q = Math.abs(Δψ) > 10e-12 ? Δφ / Δψ : Math.cos(φ1); // E-W course becomes ill-conditioned with 0/0\n\n      var Δλ = δ * Math.sin(θ) / q;\n      var λ2 = λ1 + Δλ;\n      var lat = φ2.toDegrees();\n      var lon = λ2.toDegrees();\n      return new LatLonSpherical(lat, lon);\n    }\n    /**\n     * Returns the loxodromic midpoint (along a rhumb line) between ‘this’ point and second point.\n     *\n     * @param   {LatLon} point - Latitude/longitude of second point.\n     * @returns {LatLon} Midpoint between this point and second point.\n     *\n     * @example\n     *   const p1 = new LatLon(51.127, 1.338);\n     *   const p2 = new LatLon(50.964, 1.853);\n     *   const pMid = p1.rhumbMidpointTo(p2); // 51.0455°N, 001.5957°E\n     */\n\n  }, {\n    key: \"rhumbMidpointTo\",\n    value: function rhumbMidpointTo(point) {\n      if (!(point instanceof LatLonSpherical)) point = LatLonSpherical.parse(point); // allow literal forms\n      // see mathforum.org/kb/message.jspa?messageID=148837\n\n      var φ1 = this.lat.toRadians();\n      var λ1 = this.lon.toRadians();\n      var φ2 = point.lat.toRadians(),\n          λ2 = point.lon.toRadians();\n      if (Math.abs(λ2 - λ1) > π) λ1 += 2 * π; // crossing anti-meridian\n\n      var φ3 = (φ1 + φ2) / 2;\n      var f1 = Math.tan(π / 4 + φ1 / 2);\n      var f2 = Math.tan(π / 4 + φ2 / 2);\n      var f3 = Math.tan(π / 4 + φ3 / 2);\n      var λ3 = ((λ2 - λ1) * Math.log(f3) + λ1 * Math.log(f2) - λ2 * Math.log(f1)) / Math.log(f2 / f1);\n      if (!isFinite(λ3)) λ3 = (λ1 + λ2) / 2; // parallel of latitude\n\n      var lat = φ3.toDegrees();\n      var lon = λ3.toDegrees();\n      return new LatLonSpherical(lat, lon);\n    }\n    /* Area - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n    /**\n     * Calculates the area of a spherical polygon where the sides of the polygon are great circle\n     * arcs joining the vertices.\n     *\n     * @param   {LatLon[]} polygon - Array of points defining vertices of the polygon.\n     * @param   {number}   [radius=6371e3] - (Mean) radius of earth (defaults to radius in metres).\n     * @returns {number}   The area of the polygon in the same units as radius.\n     *\n     * @example\n     *   const polygon = [new LatLon(0,0), new LatLon(1,0), new LatLon(0,1)];\n     *   const area = LatLon.areaOf(polygon); // 6.18e9 m²\n     */\n\n  }, {\n    key: \"equals\",\n\n    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n    /**\n     * Checks if another point is equal to ‘this’ point.\n     *\n     * @param   {LatLon} point - Point to be compared against this point.\n     * @returns {bool}   True if points have identical latitude and longitude values.\n     *\n     * @example\n     *   const p1 = new LatLon(52.205, 0.119);\n     *   const p2 = new LatLon(52.205, 0.119);\n     *   const equal = p1.equals(p2); // true\n     */\n    value: function equals(point) {\n      if (!(point instanceof LatLonSpherical)) point = LatLonSpherical.parse(point); // allow literal forms\n\n      if (Math.abs(this.lat - point.lat) > Number.EPSILON) return false;\n      if (Math.abs(this.lon - point.lon) > Number.EPSILON) return false;\n      return true;\n    }\n    /**\n     * Converts ‘this’ point to a GeoJSON object.\n     *\n     * @returns {Object} this point as a GeoJSON ‘Point’ object.\n     */\n\n  }, {\n    key: \"toGeoJSON\",\n    value: function toGeoJSON() {\n      return {\n        type: 'Point',\n        coordinates: [this.lon, this.lat]\n      };\n    }\n    /**\n     * Returns a string representation of ‘this’ point, formatted as degrees, degrees+minutes, or\n     * degrees+minutes+seconds.\n     *\n     * @param   {string} [format=d] - Format point as 'd', 'dm', 'dms', or 'n' for signed numeric.\n     * @param   {number} [dp=4|2|0] - Number of decimal places to use: default 4 for d, 2 for dm, 0 for dms.\n     * @returns {string} Comma-separated formatted latitude/longitude.\n     * @throws  {RangeError} Invalid format.\n     *\n     * @example\n     *   const greenwich = new LatLon(51.47788, -0.00147);\n     *   const d = greenwich.toString();                        // 51.4779°N, 000.0015°W\n     *   const dms = greenwich.toString('dms', 2);              // 51°28′40.37″N, 000°00′05.29″W\n     *   const [lat, lon] = greenwich.toString('n').split(','); // 51.4779, -0.0015\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'd';\n      var dp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      // note: explicitly set dp to undefined for passing through to toLat/toLon\n      if (!['d', 'dm', 'dms', 'n'].includes(format)) throw new RangeError(\"invalid format \\u2018\".concat(format, \"\\u2019\"));\n\n      if (format == 'n') {\n        // signed numeric degrees\n        if (dp == undefined) dp = 4;\n        return \"\".concat(this.lat.toFixed(dp), \",\").concat(this.lon.toFixed(dp));\n      }\n\n      var lat = Dms.toLat(this.lat, format, dp);\n      var lon = Dms.toLon(this.lon, format, dp);\n      return \"\".concat(lat, \", \").concat(lon);\n    }\n  }, {\n    key: \"lat\",\n    get: function get() {\n      return this._lat;\n    },\n    set: function set(lat) {\n      this._lat = isNaN(lat) ? Dms.wrap90(Dms.parse(lat)) : Dms.wrap90(lat);\n      if (isNaN(this._lat)) throw new TypeError(\"invalid lat \\u2018\".concat(lat, \"\\u2019\"));\n    }\n  }, {\n    key: \"latitude\",\n    get: function get() {\n      return this._lat;\n    },\n    set: function set(lat) {\n      this._lat = isNaN(lat) ? Dms.wrap90(Dms.parse(lat)) : Dms.wrap90(lat);\n      if (isNaN(this._lat)) throw new TypeError(\"invalid latitude \\u2018\".concat(lat, \"\\u2019\"));\n    }\n    /**\n     * Longitude in degrees east from international reference meridian (including aliases lon, lng,\n     * longitude): can be set as numeric or hexagesimal (deg-min-sec); returned as numeric.\n     */\n\n  }, {\n    key: \"lon\",\n    get: function get() {\n      return this._lon;\n    },\n    set: function set(lon) {\n      this._lon = isNaN(lon) ? Dms.wrap180(Dms.parse(lon)) : Dms.wrap180(lon);\n      if (isNaN(this._lon)) throw new TypeError(\"invalid lon \\u2018\".concat(lon, \"\\u2019\"));\n    }\n  }, {\n    key: \"lng\",\n    get: function get() {\n      return this._lon;\n    },\n    set: function set(lon) {\n      this._lon = isNaN(lon) ? Dms.wrap180(Dms.parse(lon)) : Dms.wrap180(lon);\n      if (isNaN(this._lon)) throw new TypeError(\"invalid lng \\u2018\".concat(lon, \"\\u2019\"));\n    }\n  }, {\n    key: \"longitude\",\n    get: function get() {\n      return this._lon;\n    },\n    set: function set(lon) {\n      this._lon = isNaN(lon) ? Dms.wrap180(Dms.parse(lon)) : Dms.wrap180(lon);\n      if (isNaN(this._lon)) throw new TypeError(\"invalid longitude \\u2018\".concat(lon, \"\\u2019\"));\n    }\n    /** Conversion factors; 1000 * LatLon.metresToKm gives 1. */\n\n  }], [{\n    key: \"parse\",\n\n    /**\n     * Parses a latitude/longitude point from a variety of formats.\n     *\n     * Latitude & longitude (in degrees) can be supplied as two separate parameters, as a single\n     * comma-separated lat/lon string, or as a single object with { lat, lon } or GeoJSON properties.\n     *\n     * The latitude/longitude values may be numeric or strings; they may be signed decimal or\n     * deg-min-sec (hexagesimal) suffixed by compass direction (NSEW); a variety of separators are\n     * accepted. Examples -3.62, '3 37 12W', '3°37′12″W'.\n     *\n     * Thousands/decimal separators must be comma/dot; use Dms.fromLocale to convert locale-specific\n     * thousands/decimal separators.\n     *\n     * @param   {number|string|Object} lat|latlon - Latitude (in degrees) or comma-separated lat/lon or lat/lon object.\n     * @param   {number|string}        [lon]      - Longitude (in degrees).\n     * @returns {LatLon} Latitude/longitude point.\n     * @throws  {TypeError} Invalid point.\n     *\n     * @example\n     *   const p1 = LatLon.parse(52.205, 0.119);                                    // numeric pair (≡ new LatLon)\n     *   const p2 = LatLon.parse('52.205', '0.119');                                // numeric string pair (≡ new LatLon)\n     *   const p3 = LatLon.parse('52.205, 0.119');                                  // single string numerics\n     *   const p4 = LatLon.parse('52°12′18.0″N', '000°07′08.4″E');                  // DMS pair\n     *   const p5 = LatLon.parse('52°12′18.0″N, 000°07′08.4″E');                    // single string DMS\n     *   const p6 = LatLon.parse({ lat: 52.205, lon: 0.119 });                      // { lat, lon } object numeric\n     *   const p7 = LatLon.parse({ lat: '52°12′18.0″N', lng: '000°07′08.4″E' });    // { lat, lng } object DMS\n     *   const p8 = LatLon.parse({ type: 'Point', coordinates: [ 0.119, 52.205] }); // GeoJSON\n     */\n    value: function parse() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      if (args.length === 0) throw new TypeError('invalid (empty) point');\n      if (args[0] === null || args[1] === null) throw new TypeError('invalid (null) point');\n      var lat = undefined,\n          lon = undefined;\n\n      if (args.length === 2) {\n        // regular (lat, lon) arguments\n        lat = args[0];\n        lon = args[1];\n        lat = Dms.wrap90(Dms.parse(lat));\n        lon = Dms.wrap180(Dms.parse(lon));\n        if (isNaN(lat) || isNaN(lon)) throw new TypeError(\"invalid point \\u2018\".concat(args.toString(), \"\\u2019\"));\n      }\n\n      if (args.length === 1 && typeof args[0] == 'string') {\n        // single comma-separated lat,lon string\n        var _args$0$split = args[0].split(',');\n\n        var _args$0$split2 = _slicedToArray(_args$0$split, 2);\n\n        lat = _args$0$split2[0];\n        lon = _args$0$split2[1];\n        lat = Dms.wrap90(Dms.parse(lat));\n        lon = Dms.wrap180(Dms.parse(lon));\n        if (isNaN(lat) || isNaN(lon)) throw new TypeError(\"invalid point \\u2018\".concat(args[0], \"\\u2019\"));\n      }\n\n      if (args.length === 1 && typeof args[0] == 'object') {\n        // single { lat, lon } object\n        var ll = args[0];\n\n        if (ll.type === 'Point' && Array.isArray(ll.coordinates)) {\n          // GeoJSON\n          var _ll$coordinates = _slicedToArray(ll.coordinates, 2);\n\n          lon = _ll$coordinates[0];\n          lat = _ll$coordinates[1];\n        } else {\n          // regular { lat, lon } object\n          if (ll.latitude != undefined) lat = ll.latitude;\n          if (ll.lat != undefined) lat = ll.lat;\n          if (ll.longitude != undefined) lon = ll.longitude;\n          if (ll.lng != undefined) lon = ll.lng;\n          if (ll.lon != undefined) lon = ll.lon;\n          lat = Dms.wrap90(Dms.parse(lat));\n          lon = Dms.wrap180(Dms.parse(lon));\n        }\n\n        if (isNaN(lat) || isNaN(lon)) throw new TypeError(\"invalid point \\u2018\".concat(JSON.stringify(args[0]), \"\\u2019\"));\n      }\n\n      if (isNaN(lat) || isNaN(lon)) throw new TypeError(\"invalid point \\u2018\".concat(args.toString(), \"\\u2019\"));\n      return new LatLonSpherical(lat, lon);\n    }\n  }, {\n    key: \"intersection\",\n    value: function intersection(p1, brng1, p2, brng2) {\n      if (!(p1 instanceof LatLonSpherical)) p1 = LatLonSpherical.parse(p1); // allow literal forms\n\n      if (!(p2 instanceof LatLonSpherical)) p2 = LatLonSpherical.parse(p2); // allow literal forms\n\n      if (isNaN(brng1)) throw new TypeError(\"invalid brng1 \\u2018\".concat(brng1, \"\\u2019\"));\n      if (isNaN(brng2)) throw new TypeError(\"invalid brng2 \\u2018\".concat(brng2, \"\\u2019\")); // see www.edwilliams.org/avform.htm#Intersection\n\n      var φ1 = p1.lat.toRadians(),\n          λ1 = p1.lon.toRadians();\n      var φ2 = p2.lat.toRadians(),\n          λ2 = p2.lon.toRadians();\n      var θ13 = Number(brng1).toRadians(),\n          θ23 = Number(brng2).toRadians();\n      var Δφ = φ2 - φ1,\n          Δλ = λ2 - λ1; // angular distance p1-p2\n\n      var δ12 = 2 * Math.asin(Math.sqrt(Math.sin(Δφ / 2) * Math.sin(Δφ / 2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2)));\n      if (Math.abs(δ12) < Number.EPSILON) return new LatLonSpherical(p1.lat, p1.lon); // coincident points\n      // initial/final bearings between points\n\n      var cosθa = (Math.sin(φ2) - Math.sin(φ1) * Math.cos(δ12)) / (Math.sin(δ12) * Math.cos(φ1));\n      var cosθb = (Math.sin(φ1) - Math.sin(φ2) * Math.cos(δ12)) / (Math.sin(δ12) * Math.cos(φ2));\n      var θa = Math.acos(Math.min(Math.max(cosθa, -1), 1)); // protect against rounding errors\n\n      var θb = Math.acos(Math.min(Math.max(cosθb, -1), 1)); // protect against rounding errors\n\n      var θ12 = Math.sin(λ2 - λ1) > 0 ? θa : 2 * π - θa;\n      var θ21 = Math.sin(λ2 - λ1) > 0 ? 2 * π - θb : θb;\n      var α1 = θ13 - θ12; // angle 2-1-3\n\n      var α2 = θ21 - θ23; // angle 1-2-3\n\n      if (Math.sin(α1) == 0 && Math.sin(α2) == 0) return null; // infinite intersections\n\n      if (Math.sin(α1) * Math.sin(α2) < 0) return null; // ambiguous intersection (antipodal?)\n\n      var cosα3 = -Math.cos(α1) * Math.cos(α2) + Math.sin(α1) * Math.sin(α2) * Math.cos(δ12);\n      var δ13 = Math.atan2(Math.sin(δ12) * Math.sin(α1) * Math.sin(α2), Math.cos(α2) + Math.cos(α1) * cosα3);\n      var φ3 = Math.asin(Math.sin(φ1) * Math.cos(δ13) + Math.cos(φ1) * Math.sin(δ13) * Math.cos(θ13));\n      var Δλ13 = Math.atan2(Math.sin(θ13) * Math.sin(δ13) * Math.cos(φ1), Math.cos(δ13) - Math.sin(φ1) * Math.sin(φ3));\n      var λ3 = λ1 + Δλ13;\n      var lat = φ3.toDegrees();\n      var lon = λ3.toDegrees();\n      return new LatLonSpherical(lat, lon);\n    }\n  }, {\n    key: \"crossingParallels\",\n    value: function crossingParallels(point1, point2, latitude) {\n      if (point1.equals(point2)) return null; // coincident points\n\n      var φ = Number(latitude).toRadians();\n      var φ1 = point1.lat.toRadians();\n      var λ1 = point1.lon.toRadians();\n      var φ2 = point2.lat.toRadians();\n      var λ2 = point2.lon.toRadians();\n      var Δλ = λ2 - λ1;\n      var x = Math.sin(φ1) * Math.cos(φ2) * Math.cos(φ) * Math.sin(Δλ);\n      var y = Math.sin(φ1) * Math.cos(φ2) * Math.cos(φ) * Math.cos(Δλ) - Math.cos(φ1) * Math.sin(φ2) * Math.cos(φ);\n      var z = Math.cos(φ1) * Math.cos(φ2) * Math.sin(φ) * Math.sin(Δλ);\n      if (z * z > x * x + y * y) return null; // great circle doesn't reach latitude\n\n      var λm = Math.atan2(-y, x); // longitude at max latitude\n\n      var Δλi = Math.acos(z / Math.sqrt(x * x + y * y)); // Δλ from λm to intersection points\n\n      var λi1 = λ1 + λm - Δλi;\n      var λi2 = λ1 + λm + Δλi;\n      var lon1 = λi1.toDegrees();\n      var lon2 = λi2.toDegrees();\n      return {\n        lon1: Dms.wrap180(lon1),\n        lon2: Dms.wrap180(lon2)\n      };\n    }\n  }, {\n    key: \"areaOf\",\n    value: function areaOf(polygon) {\n      var radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 6371e3;\n      // uses method due to Karney: osgeo-org.1560.x6.nabble.com/Area-of-a-spherical-polygon-td3841625.html;\n      // for each edge of the polygon, tan(E/2) = tan(Δλ/2)·(tan(φ₁/2)+tan(φ₂/2)) / (1+tan(φ₁/2)·tan(φ₂/2))\n      // where E is the spherical excess of the trapezium obtained by extending the edge to the equator\n      // (Karney's method is probably more efficient than the more widely known L’Huilier’s Theorem)\n      var R = radius; // close polygon so that last point equals first point\n\n      var closed = polygon[0].equals(polygon[polygon.length - 1]);\n      if (!closed) polygon.push(polygon[0]);\n      var nVertices = polygon.length - 1;\n      var S = 0; // spherical excess in steradians\n\n      for (var v = 0; v < nVertices; v++) {\n        var φ1 = polygon[v].lat.toRadians();\n        var φ2 = polygon[v + 1].lat.toRadians();\n        var Δλ = (polygon[v + 1].lon - polygon[v].lon).toRadians();\n        var E = 2 * Math.atan2(Math.tan(Δλ / 2) * (Math.tan(φ1 / 2) + Math.tan(φ2 / 2)), 1 + Math.tan(φ1 / 2) * Math.tan(φ2 / 2));\n        S += E;\n      }\n\n      if (isPoleEnclosedBy(polygon)) S = Math.abs(S) - 2 * π;\n      var A = Math.abs(S * R * R); // area in units of R\n\n      if (!closed) polygon.pop(); // restore polygon to pristine condition\n\n      return A; // returns whether polygon encloses pole: sum of course deltas around pole is 0° rather than\n      // normal ±360°: blog.element84.com/determining-if-a-spherical-polygon-contains-a-pole.html\n\n      function isPoleEnclosedBy(p) {\n        // TODO: any better test than this?\n        var ΣΔ = 0;\n        var prevBrng = p[0].initialBearingTo(p[1]);\n\n        for (var _v = 0; _v < p.length - 1; _v++) {\n          var _initBrng = p[_v].initialBearingTo(p[_v + 1]);\n\n          var finalBrng = p[_v].finalBearingTo(p[_v + 1]);\n\n          ΣΔ += (_initBrng - prevBrng + 540) % 360 - 180;\n          ΣΔ += (finalBrng - _initBrng + 540) % 360 - 180;\n          prevBrng = finalBrng;\n        }\n\n        var initBrng = p[0].initialBearingTo(p[1]);\n        ΣΔ += (initBrng - prevBrng + 540) % 360 - 180; // TODO: fix (intermittant) edge crossing pole - eg (85,90), (85,0), (85,-90)\n\n        var enclosed = Math.abs(ΣΔ) < 90; // 0°-ish\n\n        return enclosed;\n      }\n    }\n  }, {\n    key: \"metresToKm\",\n    get: function get() {\n      return 1 / 1000;\n    }\n    /** Conversion factors; 1000 * LatLon.metresToMiles gives 0.621371192237334. */\n\n  }, {\n    key: \"metresToMiles\",\n    get: function get() {\n      return 1 / 1609.344;\n    }\n    /** Conversion factors; 1000 * LatLon.metresToMiles gives 0.5399568034557236. */\n\n  }, {\n    key: \"metresToNauticalMiles\",\n    get: function get() {\n      return 1 / 1852;\n    }\n  }]);\n\n  return LatLonSpherical;\n}();\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n\nexport { LatLonSpherical as default, Dms };","map":{"version":3,"sources":["C:\\Projects\\Signworks3\\src\\utils\\geodesy\\latlon-spherical.js"],"names":["Dms","π","Math","PI","LatLonSpherical","lat","lon","isNaN","TypeError","_lat","wrap90","_lon","wrap180","point","radius","parse","R","φ1","toRadians","λ1","φ2","λ2","Δφ","Δλ","a","sin","cos","c","atan2","sqrt","d","equals","NaN","x","y","θ","bearing","toDegrees","wrap360","initialBearingTo","A","z","B","C","φm","λm","fraction","δ","φ3","λ3","distance","Number","sinφ2","asin","pathStart","pathEnd","δ13","distanceTo","θ13","θ12","δxt","δat","acos","abs","sign","φ","φMax","Δψ","log","tan","q","f1","f2","f3","isFinite","EPSILON","type","coordinates","format","dp","undefined","includes","RangeError","toFixed","toLat","toLon","args","length","toString","split","ll","Array","isArray","latitude","longitude","lng","JSON","stringify","p1","brng1","p2","brng2","θ23","δ12","cosθa","cosθb","θa","min","max","θb","θ21","α1","α2","cosα3","Δλ13","point1","point2","Δλi","λi1","λi2","lon1","lon2","polygon","closed","push","nVertices","S","v","E","isPoleEnclosedBy","pop","p","ΣΔ","prevBrng","initBrng","finalBrng","finalBearingTo","enclosed","default"],"mappings":"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","sourcesContent":["/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/* Latitude/longitude spherical geodesy tools                         (c) Chris Veness 2002-2019  */\n/*                                                                                   MIT Licence  */\n/* www.movable-type.co.uk/scripts/latlong.html                                                    */\n/* www.movable-type.co.uk/scripts/geodesy-library.html#latlon-spherical                           */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nimport Dms from './dms.js';\n\nconst π = Math.PI;\n\n\n/**\n * Library of geodesy functions for operations on a spherical earth model.\n *\n * Includes distances, bearings, destinations, etc, for both great circle paths and rhumb lines,\n * and other related functions.\n *\n * All calculations are done using simple spherical trigonometric formulae.\n *\n * @module latlon-spherical\n */\n\n// note greek letters (e.g. φ, λ, θ) are used for angles in radians to distinguish from angles in\n// degrees (e.g. lat, lon, brng)\n\n\n/* LatLonSpherical - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n\n/**\n * Latitude/longitude points on a spherical model earth, and methods for calculating distances,\n * bearings, destinations, etc on (orthodromic) great-circle paths and (loxodromic) rhumb lines.\n */\nclass LatLonSpherical {\n\n    /**\n     * Creates a latitude/longitude point on the earth’s surface, using a spherical model earth.\n     *\n     * @param  {number} lat - Latitude (in degrees).\n     * @param  {number} lon - Longitude (in degrees).\n     * @throws {TypeError} Invalid lat/lon.\n     *\n     * @example\n     *   import LatLon from '/js/geodesy/latlon-spherical.js';\n     *   const p = new LatLon(52.205, 0.119);\n     */\n    constructor(lat, lon) {\n        if (isNaN(lat)) throw new TypeError(`invalid lat ‘${lat}’`);\n        if (isNaN(lon)) throw new TypeError(`invalid lon ‘${lon}’`);\n\n        this._lat = Dms.wrap90(lat);\n        this._lon = Dms.wrap180(lon);\n    }\n\n\n    /**\n     * Latitude in degrees north from equator (including aliases lat, latitude): can be set as\n     * numeric or hexagesimal (deg-min-sec); returned as numeric.\n     */\n    get lat()       { return this._lat; }\n    get latitude()  { return this._lat; }\n    set lat(lat) {\n        this._lat = isNaN(lat) ? Dms.wrap90(Dms.parse(lat)) : Dms.wrap90(lat);\n        if (isNaN(this._lat)) throw new TypeError(`invalid lat ‘${lat}’`);\n    }\n    set latitude(lat) {\n        this._lat = isNaN(lat) ? Dms.wrap90(Dms.parse(lat)) : Dms.wrap90(lat);\n        if (isNaN(this._lat)) throw new TypeError(`invalid latitude ‘${lat}’`);\n    }\n\n    /**\n     * Longitude in degrees east from international reference meridian (including aliases lon, lng,\n     * longitude): can be set as numeric or hexagesimal (deg-min-sec); returned as numeric.\n     */\n    get lon()       { return this._lon; }\n    get lng()       { return this._lon; }\n    get longitude() { return this._lon; }\n    set lon(lon) {\n        this._lon = isNaN(lon) ? Dms.wrap180(Dms.parse(lon)) : Dms.wrap180(lon);\n        if (isNaN(this._lon)) throw new TypeError(`invalid lon ‘${lon}’`);\n    }\n    set lng(lon) {\n        this._lon = isNaN(lon) ? Dms.wrap180(Dms.parse(lon)) : Dms.wrap180(lon);\n        if (isNaN(this._lon)) throw new TypeError(`invalid lng ‘${lon}’`);\n    }\n    set longitude(lon) {\n        this._lon = isNaN(lon) ? Dms.wrap180(Dms.parse(lon)) : Dms.wrap180(lon);\n        if (isNaN(this._lon)) throw new TypeError(`invalid longitude ‘${lon}’`);\n    }\n\n\n    /** Conversion factors; 1000 * LatLon.metresToKm gives 1. */\n    static get metresToKm()            { return 1/1000; }\n    /** Conversion factors; 1000 * LatLon.metresToMiles gives 0.621371192237334. */\n    static get metresToMiles()         { return 1/1609.344; }\n    /** Conversion factors; 1000 * LatLon.metresToMiles gives 0.5399568034557236. */\n    static get metresToNauticalMiles() { return 1/1852; }\n\n\n    /**\n     * Parses a latitude/longitude point from a variety of formats.\n     *\n     * Latitude & longitude (in degrees) can be supplied as two separate parameters, as a single\n     * comma-separated lat/lon string, or as a single object with { lat, lon } or GeoJSON properties.\n     *\n     * The latitude/longitude values may be numeric or strings; they may be signed decimal or\n     * deg-min-sec (hexagesimal) suffixed by compass direction (NSEW); a variety of separators are\n     * accepted. Examples -3.62, '3 37 12W', '3°37′12″W'.\n     *\n     * Thousands/decimal separators must be comma/dot; use Dms.fromLocale to convert locale-specific\n     * thousands/decimal separators.\n     *\n     * @param   {number|string|Object} lat|latlon - Latitude (in degrees) or comma-separated lat/lon or lat/lon object.\n     * @param   {number|string}        [lon]      - Longitude (in degrees).\n     * @returns {LatLon} Latitude/longitude point.\n     * @throws  {TypeError} Invalid point.\n     *\n     * @example\n     *   const p1 = LatLon.parse(52.205, 0.119);                                    // numeric pair (≡ new LatLon)\n     *   const p2 = LatLon.parse('52.205', '0.119');                                // numeric string pair (≡ new LatLon)\n     *   const p3 = LatLon.parse('52.205, 0.119');                                  // single string numerics\n     *   const p4 = LatLon.parse('52°12′18.0″N', '000°07′08.4″E');                  // DMS pair\n     *   const p5 = LatLon.parse('52°12′18.0″N, 000°07′08.4″E');                    // single string DMS\n     *   const p6 = LatLon.parse({ lat: 52.205, lon: 0.119 });                      // { lat, lon } object numeric\n     *   const p7 = LatLon.parse({ lat: '52°12′18.0″N', lng: '000°07′08.4″E' });    // { lat, lng } object DMS\n     *   const p8 = LatLon.parse({ type: 'Point', coordinates: [ 0.119, 52.205] }); // GeoJSON\n     */\n    static parse(...args) {\n        if (args.length === 0) throw new TypeError('invalid (empty) point');\n        if (args[0]===null || args[1]===null) throw new TypeError('invalid (null) point');\n\n        let lat=undefined, lon=undefined;\n\n        if (args.length === 2) { // regular (lat, lon) arguments\n            [ lat, lon ] = args;\n            lat = Dms.wrap90(Dms.parse(lat));\n            lon = Dms.wrap180(Dms.parse(lon));\n            if (isNaN(lat) || isNaN(lon)) throw new TypeError(`invalid point ‘${args.toString()}’`);\n        }\n\n        if (args.length === 1 && typeof args[0] == 'string') { // single comma-separated lat,lon string\n            [ lat, lon ] = args[0].split(',');\n            lat = Dms.wrap90(Dms.parse(lat));\n            lon = Dms.wrap180(Dms.parse(lon));\n            if (isNaN(lat) || isNaN(lon)) throw new TypeError(`invalid point ‘${args[0]}’`);\n        }\n\n        if (args.length === 1 && typeof args[0] == 'object') { // single { lat, lon } object\n            const ll = args[0];\n            if (ll.type === 'Point' && Array.isArray(ll.coordinates)) { // GeoJSON\n                [ lon, lat ] = ll.coordinates;\n            } else { // regular { lat, lon } object\n                if (ll.latitude  != undefined) lat = ll.latitude;\n                if (ll.lat       != undefined) lat = ll.lat;\n                if (ll.longitude != undefined) lon = ll.longitude;\n                if (ll.lng       != undefined) lon = ll.lng;\n                if (ll.lon       != undefined) lon = ll.lon;\n                lat = Dms.wrap90(Dms.parse(lat));\n                lon = Dms.wrap180(Dms.parse(lon));\n            }\n            if (isNaN(lat) || isNaN(lon)) throw new TypeError(`invalid point ‘${JSON.stringify(args[0])}’`);\n        }\n\n        if (isNaN(lat) || isNaN(lon)) throw new TypeError(`invalid point ‘${args.toString()}’`);\n\n        return new LatLonSpherical(lat, lon);\n    }\n\n\n    /**\n     * Returns the distance along the surface of the earth from ‘this’ point to destination point.\n     *\n     * Uses haversine formula: a = sin²(Δφ/2) + cosφ1·cosφ2 · sin²(Δλ/2); d = 2 · atan2(√a, √(a-1)).\n     *\n     * @param   {LatLon} point - Latitude/longitude of destination point.\n     * @param   {number} [radius=6371e3] - Radius of earth (defaults to mean radius in metres).\n     * @returns {number} Distance between this point and destination point, in same units as radius.\n     * @throws  {TypeError} Invalid radius.\n     *\n     * @example\n     *   const p1 = new LatLon(52.205, 0.119);\n     *   const p2 = new LatLon(48.857, 2.351);\n     *   const d = p1.distanceTo(p2);       // 404.3×10³ m\n     *   const m = p1.distanceTo(p2, 3959); // 251.2 miles\n     */\n    distanceTo(point, radius=6371e3) {\n        if (!(point instanceof LatLonSpherical)) point = LatLonSpherical.parse(point); // allow literal forms\n        if (isNaN(radius)) throw new TypeError(`invalid radius ‘${radius}’`);\n\n        // a = sin²(Δφ/2) + cos(φ1)⋅cos(φ2)⋅sin²(Δλ/2)\n        // δ = 2·atan2(√(a), √(1−a))\n        // see mathforum.org/library/drmath/view/51879.html for derivation\n\n        const R = radius;\n        const φ1 = this.lat.toRadians(),  λ1 = this.lon.toRadians();\n        const φ2 = point.lat.toRadians(), λ2 = point.lon.toRadians();\n        const Δφ = φ2 - φ1;\n        const Δλ = λ2 - λ1;\n\n        const a = Math.sin(Δφ/2)*Math.sin(Δφ/2) + Math.cos(φ1)*Math.cos(φ2) * Math.sin(Δλ/2)*Math.sin(Δλ/2);\n        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n        const d = R * c;\n\n        return d;\n    }\n\n\n    /**\n     * Returns the initial bearing from ‘this’ point to destination point.\n     *\n     * @param   {LatLon} point - Latitude/longitude of destination point.\n     * @returns {number} Initial bearing in degrees from north (0°..360°).\n     *\n     * @example\n     *   const p1 = new LatLon(52.205, 0.119);\n     *   const p2 = new LatLon(48.857, 2.351);\n     *   const b1 = p1.initialBearingTo(p2); // 156.2°\n     */\n    initialBearingTo(point) {\n        if (!(point instanceof LatLonSpherical)) point = LatLonSpherical.parse(point); // allow literal forms\n        if (this.equals(point)) return NaN; // coincident points\n\n        // tanθ = sinΔλ⋅cosφ2 / cosφ1⋅sinφ2 − sinφ1⋅cosφ2⋅cosΔλ\n        // see mathforum.org/library/drmath/view/55417.html for derivation\n\n        const φ1 = this.lat.toRadians();\n        const φ2 = point.lat.toRadians();\n        const Δλ = (point.lon - this.lon).toRadians();\n\n        const x = Math.cos(φ1) * Math.sin(φ2) - Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);\n        const y = Math.sin(Δλ) * Math.cos(φ2);\n        const θ = Math.atan2(y, x);\n\n        const bearing = θ.toDegrees();\n\n        return Dms.wrap360(bearing);\n    }\n\n\n    /**\n     * Returns final bearing arriving at destination point from ‘this’ point; the final bearing will\n     * differ from the initial bearing by varying degrees according to distance and latitude.\n     *\n     * @param   {LatLon} point - Latitude/longitude of destination point.\n     * @returns {number} Final bearing in degrees from north (0°..360°).\n     *\n     * @example\n     *   const p1 = new LatLon(52.205, 0.119);\n     *   const p2 = new LatLon(48.857, 2.351);\n     *   const b2 = p1.finalBearingTo(p2); // 157.9°\n     */\n    finalBearingTo(point) {\n        if (!(point instanceof LatLonSpherical)) point = LatLonSpherical.parse(point); // allow literal forms\n\n        // get initial bearing from destination point to this point & reverse it by adding 180°\n\n        const bearing = point.initialBearingTo(this) + 180;\n\n        return Dms.wrap360(bearing);\n    }\n\n\n    /**\n     * Returns the midpoint between ‘this’ point and destination point.\n     *\n     * @param   {LatLon} point - Latitude/longitude of destination point.\n     * @returns {LatLon} Midpoint between this point and destination point.\n     *\n     * @example\n     *   const p1 = new LatLon(52.205, 0.119);\n     *   const p2 = new LatLon(48.857, 2.351);\n     *   const pMid = p1.midpointTo(p2); // 50.5363°N, 001.2746°E\n     */\n    midpointTo(point) {\n        if (!(point instanceof LatLonSpherical)) point = LatLonSpherical.parse(point); // allow literal forms\n\n        // φm = atan2( sinφ1 + sinφ2, √( (cosφ1 + cosφ2⋅cosΔλ)² + cos²φ2⋅sin²Δλ ) )\n        // λm = λ1 + atan2(cosφ2⋅sinΔλ, cosφ1 + cosφ2⋅cosΔλ)\n        // midpoint is sum of vectors to two points: mathforum.org/library/drmath/view/51822.html\n\n        const φ1 = this.lat.toRadians();\n        const λ1 = this.lon.toRadians();\n        const φ2 = point.lat.toRadians();\n        const Δλ = (point.lon - this.lon).toRadians();\n\n        // get cartesian coordinates for the two points\n        const A = { x: Math.cos(φ1), y: 0, z: Math.sin(φ1) }; // place point A on prime meridian y=0\n        const B = { x: Math.cos(φ2)*Math.cos(Δλ), y: Math.cos(φ2)*Math.sin(Δλ), z: Math.sin(φ2) };\n\n        // vector to midpoint is sum of vectors to two points (no need to normalise)\n        const C = { x: A.x + B.x, y: A.y + B.y, z: A.z + B.z };\n\n        const φm = Math.atan2(C.z, Math.sqrt(C.x*C.x + C.y*C.y));\n        const λm = λ1 + Math.atan2(C.y, C.x);\n\n        const lat = φm.toDegrees();\n        const lon = λm.toDegrees();\n\n        return new LatLonSpherical(lat, lon);\n    }\n\n\n    /**\n     * Returns the point at given fraction between ‘this’ point and given point.\n     *\n     * @param   {LatLon} point - Latitude/longitude of destination point.\n     * @param   {number} fraction - Fraction between the two points (0 = this point, 1 = specified point).\n     * @returns {LatLon} Intermediate point between this point and destination point.\n     *\n     * @example\n     *   const p1 = new LatLon(52.205, 0.119);\n     *   const p2 = new LatLon(48.857, 2.351);\n     *   const pInt = p1.intermediatePointTo(p2, 0.25); // 51.3721°N, 000.7073°E\n     */\n    intermediatePointTo(point, fraction) {\n        if (!(point instanceof LatLonSpherical)) point = LatLonSpherical.parse(point); // allow literal forms\n        if (this.equals(point)) return new LatLonSpherical(this.lat, this.lon); // coincident points\n\n        const φ1 = this.lat.toRadians(), λ1 = this.lon.toRadians();\n        const φ2 = point.lat.toRadians(), λ2 = point.lon.toRadians();\n\n        // distance between points\n        const Δφ = φ2 - φ1;\n        const Δλ = λ2 - λ1;\n        const a = Math.sin(Δφ/2) * Math.sin(Δφ/2)\n            + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ/2) * Math.sin(Δλ/2);\n        const δ = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n\n        const A = Math.sin((1-fraction)*δ) / Math.sin(δ);\n        const B = Math.sin(fraction*δ) / Math.sin(δ);\n\n        const x = A * Math.cos(φ1) * Math.cos(λ1) + B * Math.cos(φ2) * Math.cos(λ2);\n        const y = A * Math.cos(φ1) * Math.sin(λ1) + B * Math.cos(φ2) * Math.sin(λ2);\n        const z = A * Math.sin(φ1) + B * Math.sin(φ2);\n\n        const φ3 = Math.atan2(z, Math.sqrt(x*x + y*y));\n        const λ3 = Math.atan2(y, x);\n\n        const lat = φ3.toDegrees();\n        const lon = λ3.toDegrees();\n\n        return new LatLonSpherical(lat, lon);\n    }\n\n\n    /**\n     * Returns the destination point from ‘this’ point having travelled the given distance on the\n     * given initial bearing (bearing normally varies around path followed).\n     *\n     * @param   {number} distance - Distance travelled, in same units as earth radius (default: metres).\n     * @param   {number} bearing - Initial bearing in degrees from north.\n     * @param   {number} [radius=6371e3] - (Mean) radius of earth (defaults to radius in metres).\n     * @returns {LatLon} Destination point.\n     *\n     * @example\n     *   const p1 = new LatLon(51.47788, -0.00147);\n     *   const p2 = p1.destinationPoint(7794, 300.7); // 51.5136°N, 000.0983°W\n     */\n    destinationPoint(distance, bearing, radius=6371e3) {\n        // sinφ2 = sinφ1⋅cosδ + cosφ1⋅sinδ⋅cosθ\n        // tanΔλ = sinθ⋅sinδ⋅cosφ1 / cosδ−sinφ1⋅sinφ2\n        // see mathforum.org/library/drmath/view/52049.html for derivation\n\n        const δ = distance / radius; // angular distance in radians\n        const θ = Number(bearing).toRadians();\n\n        const φ1 = this.lat.toRadians(), λ1 = this.lon.toRadians();\n\n        const sinφ2 = Math.sin(φ1) * Math.cos(δ) + Math.cos(φ1) * Math.sin(δ) * Math.cos(θ);\n        const φ2 = Math.asin(sinφ2);\n        const y = Math.sin(θ) * Math.sin(δ) * Math.cos(φ1);\n        const x = Math.cos(δ) - Math.sin(φ1) * sinφ2;\n        const λ2 = λ1 + Math.atan2(y, x);\n\n        const lat = φ2.toDegrees();\n        const lon = λ2.toDegrees();\n\n        return new LatLonSpherical(lat, lon);\n    }\n\n\n    /**\n     * Returns the point of intersection of two paths defined by point and bearing.\n     *\n     * @param   {LatLon}      p1 - First point.\n     * @param   {number}      brng1 - Initial bearing from first point.\n     * @param   {LatLon}      p2 - Second point.\n     * @param   {number}      brng2 - Initial bearing from second point.\n     * @returns {LatLon|null} Destination point (null if no unique intersection defined).\n     *\n     * @example\n     *   const p1 = new LatLon(51.8853, 0.2545), brng1 = 108.547;\n     *   const p2 = new LatLon(49.0034, 2.5735), brng2 =  32.435;\n     *   const pInt = LatLon.intersection(p1, brng1, p2, brng2); // 50.9078°N, 004.5084°E\n     */\n    static intersection(p1, brng1, p2, brng2) {\n        if (!(p1 instanceof LatLonSpherical)) p1 = LatLonSpherical.parse(p1); // allow literal forms\n        if (!(p2 instanceof LatLonSpherical)) p2 = LatLonSpherical.parse(p2); // allow literal forms\n        if (isNaN(brng1)) throw new TypeError(`invalid brng1 ‘${brng1}’`);\n        if (isNaN(brng2)) throw new TypeError(`invalid brng2 ‘${brng2}’`);\n\n        // see www.edwilliams.org/avform.htm#Intersection\n\n        const φ1 = p1.lat.toRadians(), λ1 = p1.lon.toRadians();\n        const φ2 = p2.lat.toRadians(), λ2 = p2.lon.toRadians();\n        const θ13 = Number(brng1).toRadians(), θ23 = Number(brng2).toRadians();\n        const Δφ = φ2 - φ1, Δλ = λ2 - λ1;\n\n        // angular distance p1-p2\n        const δ12 = 2 * Math.asin(Math.sqrt(Math.sin(Δφ/2) * Math.sin(Δφ/2)\n            + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ/2) * Math.sin(Δλ/2)));\n        if (Math.abs(δ12) < Number.EPSILON) return new LatLonSpherical(p1.lat, p1.lon); // coincident points\n\n        // initial/final bearings between points\n        const cosθa = (Math.sin(φ2) - Math.sin(φ1)*Math.cos(δ12)) / (Math.sin(δ12)*Math.cos(φ1));\n        const cosθb = (Math.sin(φ1) - Math.sin(φ2)*Math.cos(δ12)) / (Math.sin(δ12)*Math.cos(φ2));\n        const θa = Math.acos(Math.min(Math.max(cosθa, -1), 1)); // protect against rounding errors\n        const θb = Math.acos(Math.min(Math.max(cosθb, -1), 1)); // protect against rounding errors\n\n        const θ12 = Math.sin(λ2-λ1)>0 ? θa : 2*π-θa;\n        const θ21 = Math.sin(λ2-λ1)>0 ? 2*π-θb : θb;\n\n        const α1 = θ13 - θ12; // angle 2-1-3\n        const α2 = θ21 - θ23; // angle 1-2-3\n\n        if (Math.sin(α1) == 0 && Math.sin(α2) == 0) return null; // infinite intersections\n        if (Math.sin(α1) * Math.sin(α2) < 0) return null;        // ambiguous intersection (antipodal?)\n\n        const cosα3 = -Math.cos(α1)*Math.cos(α2) + Math.sin(α1)*Math.sin(α2)*Math.cos(δ12);\n\n        const δ13 = Math.atan2(Math.sin(δ12)*Math.sin(α1)*Math.sin(α2), Math.cos(α2) + Math.cos(α1)*cosα3);\n\n        const φ3 = Math.asin(Math.sin(φ1)*Math.cos(δ13) + Math.cos(φ1)*Math.sin(δ13)*Math.cos(θ13));\n\n        const Δλ13 = Math.atan2(Math.sin(θ13)*Math.sin(δ13)*Math.cos(φ1), Math.cos(δ13) - Math.sin(φ1)*Math.sin(φ3));\n        const λ3 = λ1 + Δλ13;\n\n        const lat = φ3.toDegrees();\n        const lon = λ3.toDegrees();\n\n        return new LatLonSpherical(lat, lon);\n    }\n\n\n    /**\n     * Returns (signed) distance from ‘this’ point to great circle defined by start-point and\n     * end-point.\n     *\n     * @param   {LatLon} pathStart - Start point of great circle path.\n     * @param   {LatLon} pathEnd - End point of great circle path.\n     * @param   {number} [radius=6371e3] - (Mean) radius of earth (defaults to radius in metres).\n     * @returns {number} Distance to great circle (-ve if to left, +ve if to right of path).\n     *\n     * @example\n     *   const pCurrent = new LatLon(53.2611, -0.7972);\n     *   const p1 = new LatLon(53.3206, -1.7297);\n     *   const p2 = new LatLon(53.1887, 0.1334);\n     *   const d = pCurrent.crossTrackDistanceTo(p1, p2);  // -307.5 m\n     */\n    crossTrackDistanceTo(pathStart, pathEnd, radius=6371e3) {\n        if (!(pathStart instanceof LatLonSpherical)) pathStart = LatLonSpherical.parse(pathStart); // allow literal forms\n        if (!(pathEnd instanceof LatLonSpherical)) pathEnd = LatLonSpherical.parse(pathEnd);       // allow literal forms\n        const R = radius;\n\n        const δ13 = pathStart.distanceTo(this, R) / R;\n        const θ13 = pathStart.initialBearingTo(this).toRadians();\n        const θ12 = pathStart.initialBearingTo(pathEnd).toRadians();\n\n        const δxt = Math.asin(Math.sin(δ13) * Math.sin(θ13 - θ12));\n\n        return δxt * R;\n    }\n\n\n    /**\n     * Returns how far ‘this’ point is along a path from from start-point, heading towards end-point.\n     * That is, if a perpendicular is drawn from ‘this’ point to the (great circle) path, the\n     * along-track distance is the distance from the start point to where the perpendicular crosses\n     * the path.\n     *\n     * @param   {LatLon} pathStart - Start point of great circle path.\n     * @param   {LatLon} pathEnd - End point of great circle path.\n     * @param   {number} [radius=6371e3] - (Mean) radius of earth (defaults to radius in metres).\n     * @returns {number} Distance along great circle to point nearest ‘this’ point.\n     *\n     * @example\n     *   const pCurrent = new LatLon(53.2611, -0.7972);\n     *   const p1 = new LatLon(53.3206, -1.7297);\n     *   const p2 = new LatLon(53.1887,  0.1334);\n     *   const d = pCurrent.alongTrackDistanceTo(p1, p2);  // 62.331 km\n     */\n    alongTrackDistanceTo(pathStart, pathEnd, radius=6371e3) {\n        if (!(pathStart instanceof LatLonSpherical)) pathStart = LatLonSpherical.parse(pathStart); // allow literal forms\n        if (!(pathEnd instanceof LatLonSpherical)) pathEnd = LatLonSpherical.parse(pathEnd);       // allow literal forms\n        const R = radius;\n\n        const δ13 = pathStart.distanceTo(this, R) / R;\n        const θ13 = pathStart.initialBearingTo(this).toRadians();\n        const θ12 = pathStart.initialBearingTo(pathEnd).toRadians();\n\n        const δxt = Math.asin(Math.sin(δ13) * Math.sin(θ13-θ12));\n\n        const δat = Math.acos(Math.cos(δ13) / Math.abs(Math.cos(δxt)));\n\n        return δat*Math.sign(Math.cos(θ12-θ13)) * R;\n    }\n\n\n    /**\n     * Returns maximum latitude reached when travelling on a great circle on given bearing from\n     * ‘this’ point (‘Clairaut’s formula’). Negate the result for the minimum latitude (in the\n     * southern hemisphere).\n     *\n     * The maximum latitude is independent of longitude; it will be the same for all points on a\n     * given latitude.\n     *\n     * @param   {number} bearing - Initial bearing.\n     * @returns {number} Maximum latitude reached.\n     */\n    maxLatitude(bearing) {\n        const θ = Number(bearing).toRadians();\n\n        const φ = this.lat.toRadians();\n\n        const φMax = Math.acos(Math.abs(Math.sin(θ) * Math.cos(φ)));\n\n        return φMax.toDegrees();\n    }\n\n\n    /**\n     * Returns the pair of meridians at which a great circle defined by two points crosses the given\n     * latitude. If the great circle doesn't reach the given latitude, null is returned.\n     *\n     * @param   {LatLon}      point1 - First point defining great circle.\n     * @param   {LatLon}      point2 - Second point defining great circle.\n     * @param   {number}      latitude - Latitude crossings are to be determined for.\n     * @returns {Object|null} Object containing { lon1, lon2 } or null if given latitude not reached.\n     */\n    static crossingParallels(point1, point2, latitude) {\n        if (point1.equals(point2)) return null; // coincident points\n\n        const φ = Number(latitude).toRadians();\n\n        const φ1 = point1.lat.toRadians();\n        const λ1 = point1.lon.toRadians();\n        const φ2 = point2.lat.toRadians();\n        const λ2 = point2.lon.toRadians();\n\n        const Δλ = λ2 - λ1;\n\n        const x = Math.sin(φ1) * Math.cos(φ2) * Math.cos(φ) * Math.sin(Δλ);\n        const y = Math.sin(φ1) * Math.cos(φ2) * Math.cos(φ) * Math.cos(Δλ) - Math.cos(φ1) * Math.sin(φ2) * Math.cos(φ);\n        const z = Math.cos(φ1) * Math.cos(φ2) * Math.sin(φ) * Math.sin(Δλ);\n\n        if (z * z > x * x + y * y) return null; // great circle doesn't reach latitude\n\n        const λm = Math.atan2(-y, x);               // longitude at max latitude\n        const Δλi = Math.acos(z / Math.sqrt(x*x + y*y)); // Δλ from λm to intersection points\n\n        const λi1 = λ1 + λm - Δλi;\n        const λi2 = λ1 + λm + Δλi;\n\n        const lon1 = λi1.toDegrees();\n        const lon2 = λi2.toDegrees();\n\n        return {\n            lon1: Dms.wrap180(lon1),\n            lon2: Dms.wrap180(lon2),\n        };\n    }\n\n\n    /* Rhumb - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n\n    /**\n     * Returns the distance travelling from ‘this’ point to destination point along a rhumb line.\n     *\n     * @param   {LatLon} point - Latitude/longitude of destination point.\n     * @param   {number} [radius=6371e3] - (Mean) radius of earth (defaults to radius in metres).\n     * @returns {number} Distance in km between this point and destination point (same units as radius).\n     *\n     * @example\n     *   const p1 = new LatLon(51.127, 1.338);\n     *   const p2 = new LatLon(50.964, 1.853);\n     *   const d = p1.distanceTo(p2); //  40.31 km\n     */\n    rhumbDistanceTo(point, radius=6371e3) {\n        if (!(point instanceof LatLonSpherical)) point = LatLonSpherical.parse(point); // allow literal forms\n\n        // see www.edwilliams.org/avform.htm#Rhumb\n\n        const R = radius;\n        const φ1 = this.lat.toRadians();\n        const φ2 = point.lat.toRadians();\n        const Δφ = φ2 - φ1;\n        let Δλ = Math.abs(point.lon - this.lon).toRadians();\n        // if dLon over 180° take shorter rhumb line across the anti-meridian:\n        if (Math.abs(Δλ) > π) Δλ = Δλ > 0 ? -(2 * π - Δλ) : (2 * π + Δλ);\n\n        // on Mercator projection, longitude distances shrink by latitude; q is the 'stretch factor'\n        // q becomes ill-conditioned along E-W line (0/0); use empirical tolerance to avoid it\n        const Δψ = Math.log(Math.tan(φ2 / 2 + π / 4) / Math.tan(φ1 / 2 + π / 4));\n        const q = Math.abs(Δψ) > 10e-12 ? Δφ / Δψ : Math.cos(φ1);\n\n        // distance is pythagoras on 'stretched' Mercator projection, √(Δφ² + q²·Δλ²)\n        const δ = Math.sqrt(Δφ*Δφ + q*q * Δλ*Δλ); // angular distance in radians\n        const d = δ * R;\n\n        return d;\n    }\n\n\n    /**\n     * Returns the bearing from ‘this’ point to destination point along a rhumb line.\n     *\n     * @param   {LatLon}    point - Latitude/longitude of destination point.\n     * @returns {number}    Bearing in degrees from north.\n     *\n     * @example\n     *   const p1 = new LatLon(51.127, 1.338);\n     *   const p2 = new LatLon(50.964, 1.853);\n     *   const d = p1.rhumbBearingTo(p2); // 116.7°\n     */\n    rhumbBearingTo(point) {\n        if (!(point instanceof LatLonSpherical)) point = LatLonSpherical.parse(point); // allow literal forms\n        if (this.equals(point)) return NaN; // coincident points\n\n        const φ1 = this.lat.toRadians();\n        const φ2 = point.lat.toRadians();\n        let Δλ = (point.lon - this.lon).toRadians();\n        // if dLon over 180° take shorter rhumb line across the anti-meridian:\n        if (Math.abs(Δλ) > π) Δλ = Δλ > 0 ? -(2 * π - Δλ) : (2 * π + Δλ);\n\n        const Δψ = Math.log(Math.tan(φ2 / 2 + π / 4) / Math.tan(φ1 / 2 + π / 4));\n\n        const θ = Math.atan2(Δλ, Δψ);\n\n        const bearing = θ.toDegrees();\n\n        return Dms.wrap360(bearing);\n    }\n\n\n    /**\n     * Returns the destination point having travelled along a rhumb line from ‘this’ point the given\n     * distance on the given bearing.\n     *\n     * @param   {number} distance - Distance travelled, in same units as earth radius (default: metres).\n     * @param   {number} bearing - Bearing in degrees from north.\n     * @param   {number} [radius=6371e3] - (Mean) radius of earth (defaults to radius in metres).\n     * @returns {LatLon} Destination point.\n     *\n     * @example\n     *   const p1 = new LatLon(51.127, 1.338);\n     *   const p2 = p1.rhumbDestinationPoint(40300, 116.7); // 50.9642°N, 001.8530°E\n     */\n    rhumbDestinationPoint(distance, bearing, radius=6371e3) {\n        const φ1 = this.lat.toRadians(), λ1 = this.lon.toRadians();\n        const θ = Number(bearing).toRadians();\n\n        const δ = distance / radius; // angular distance in radians\n\n        const Δφ = δ * Math.cos(θ);\n        let φ2 = φ1 + Δφ;\n\n        // check for some daft bugger going past the pole, normalise latitude if so\n        if (Math.abs(φ2) > π / 2) φ2 = φ2 > 0 ? π - φ2 : -π - φ2;\n\n        const Δψ = Math.log(Math.tan(φ2 / 2 + π / 4) / Math.tan(φ1 / 2 + π / 4));\n        const q = Math.abs(Δψ) > 10e-12 ? Δφ / Δψ : Math.cos(φ1); // E-W course becomes ill-conditioned with 0/0\n\n        const Δλ = δ * Math.sin(θ) / q;\n        const λ2 = λ1 + Δλ;\n\n        const lat = φ2.toDegrees();\n        const lon = λ2.toDegrees();\n\n        return new LatLonSpherical(lat, lon);\n    }\n\n\n    /**\n     * Returns the loxodromic midpoint (along a rhumb line) between ‘this’ point and second point.\n     *\n     * @param   {LatLon} point - Latitude/longitude of second point.\n     * @returns {LatLon} Midpoint between this point and second point.\n     *\n     * @example\n     *   const p1 = new LatLon(51.127, 1.338);\n     *   const p2 = new LatLon(50.964, 1.853);\n     *   const pMid = p1.rhumbMidpointTo(p2); // 51.0455°N, 001.5957°E\n     */\n    rhumbMidpointTo(point) {\n        if (!(point instanceof LatLonSpherical)) point = LatLonSpherical.parse(point); // allow literal forms\n\n        // see mathforum.org/kb/message.jspa?messageID=148837\n\n        const φ1 = this.lat.toRadians(); let λ1 = this.lon.toRadians();\n        const φ2 = point.lat.toRadians(), λ2 = point.lon.toRadians();\n\n        if (Math.abs(λ2 - λ1) > π) λ1 += 2 * π; // crossing anti-meridian\n\n        const φ3 = (φ1 + φ2) / 2;\n        const f1 = Math.tan(π / 4 + φ1 / 2);\n        const f2 = Math.tan(π / 4 + φ2 / 2);\n        const f3 = Math.tan(π / 4 + φ3 / 2);\n        let λ3 = ((λ2 - λ1) * Math.log(f3) + λ1 * Math.log(f2) - λ2 * Math.log(f1)) / Math.log(f2 / f1);\n\n        if (!isFinite(λ3)) λ3 = (λ1 + λ2) / 2; // parallel of latitude\n\n        const lat = φ3.toDegrees();\n        const lon = λ3.toDegrees();\n\n        return new LatLonSpherical(lat, lon);\n    }\n\n\n    /* Area - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n\n    /**\n     * Calculates the area of a spherical polygon where the sides of the polygon are great circle\n     * arcs joining the vertices.\n     *\n     * @param   {LatLon[]} polygon - Array of points defining vertices of the polygon.\n     * @param   {number}   [radius=6371e3] - (Mean) radius of earth (defaults to radius in metres).\n     * @returns {number}   The area of the polygon in the same units as radius.\n     *\n     * @example\n     *   const polygon = [new LatLon(0,0), new LatLon(1,0), new LatLon(0,1)];\n     *   const area = LatLon.areaOf(polygon); // 6.18e9 m²\n     */\n    static areaOf(polygon, radius=6371e3) {\n        // uses method due to Karney: osgeo-org.1560.x6.nabble.com/Area-of-a-spherical-polygon-td3841625.html;\n        // for each edge of the polygon, tan(E/2) = tan(Δλ/2)·(tan(φ₁/2)+tan(φ₂/2)) / (1+tan(φ₁/2)·tan(φ₂/2))\n        // where E is the spherical excess of the trapezium obtained by extending the edge to the equator\n        // (Karney's method is probably more efficient than the more widely known L’Huilier’s Theorem)\n\n        const R = radius;\n\n        // close polygon so that last point equals first point\n        const closed = polygon[0].equals(polygon[polygon.length-1]);\n        if (!closed) polygon.push(polygon[0]);\n\n        const nVertices = polygon.length - 1;\n\n        let S = 0; // spherical excess in steradians\n        for (let v=0; v<nVertices; v++) {\n            const φ1 = polygon[v].lat.toRadians();\n            const φ2 = polygon[v+1].lat.toRadians();\n            const Δλ = (polygon[v+1].lon - polygon[v].lon).toRadians();\n            const E = 2 * Math.atan2(Math.tan(Δλ/2) * (Math.tan(φ1/2)+Math.tan(φ2/2)), 1 + Math.tan(φ1/2)*Math.tan(φ2/2));\n            S += E;\n        }\n\n        if (isPoleEnclosedBy(polygon)) S = Math.abs(S) - 2*π;\n\n        const A = Math.abs(S * R*R); // area in units of R\n\n        if (!closed) polygon.pop(); // restore polygon to pristine condition\n\n        return A;\n\n        // returns whether polygon encloses pole: sum of course deltas around pole is 0° rather than\n        // normal ±360°: blog.element84.com/determining-if-a-spherical-polygon-contains-a-pole.html\n        function isPoleEnclosedBy(p) {\n            // TODO: any better test than this?\n            let ΣΔ = 0;\n            let prevBrng = p[0].initialBearingTo(p[1]);\n            for (let v=0; v<p.length-1; v++) {\n                const initBrng = p[v].initialBearingTo(p[v+1]);\n                const finalBrng = p[v].finalBearingTo(p[v+1]);\n                ΣΔ += (initBrng - prevBrng + 540) % 360 - 180;\n                ΣΔ += (finalBrng - initBrng + 540) % 360 - 180;\n                prevBrng = finalBrng;\n            }\n            const initBrng = p[0].initialBearingTo(p[1]);\n            ΣΔ += (initBrng - prevBrng + 540) % 360 - 180;\n            // TODO: fix (intermittant) edge crossing pole - eg (85,90), (85,0), (85,-90)\n            const enclosed = Math.abs(ΣΔ) < 90; // 0°-ish\n            return enclosed;\n        }\n    }\n\n\n    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n\n    /**\n     * Checks if another point is equal to ‘this’ point.\n     *\n     * @param   {LatLon} point - Point to be compared against this point.\n     * @returns {bool}   True if points have identical latitude and longitude values.\n     *\n     * @example\n     *   const p1 = new LatLon(52.205, 0.119);\n     *   const p2 = new LatLon(52.205, 0.119);\n     *   const equal = p1.equals(p2); // true\n     */\n    equals(point) {\n        if (!(point instanceof LatLonSpherical)) point = LatLonSpherical.parse(point); // allow literal forms\n\n        if (Math.abs(this.lat - point.lat) > Number.EPSILON) return false;\n        if (Math.abs(this.lon - point.lon) > Number.EPSILON) return false;\n\n        return true;\n    }\n\n\n    /**\n     * Converts ‘this’ point to a GeoJSON object.\n     *\n     * @returns {Object} this point as a GeoJSON ‘Point’ object.\n     */\n    toGeoJSON() {\n        return { type: 'Point', coordinates: [ this.lon, this.lat ] };\n    }\n\n\n    /**\n     * Returns a string representation of ‘this’ point, formatted as degrees, degrees+minutes, or\n     * degrees+minutes+seconds.\n     *\n     * @param   {string} [format=d] - Format point as 'd', 'dm', 'dms', or 'n' for signed numeric.\n     * @param   {number} [dp=4|2|0] - Number of decimal places to use: default 4 for d, 2 for dm, 0 for dms.\n     * @returns {string} Comma-separated formatted latitude/longitude.\n     * @throws  {RangeError} Invalid format.\n     *\n     * @example\n     *   const greenwich = new LatLon(51.47788, -0.00147);\n     *   const d = greenwich.toString();                        // 51.4779°N, 000.0015°W\n     *   const dms = greenwich.toString('dms', 2);              // 51°28′40.37″N, 000°00′05.29″W\n     *   const [lat, lon] = greenwich.toString('n').split(','); // 51.4779, -0.0015\n     */\n    toString(format='d', dp=undefined) {\n        // note: explicitly set dp to undefined for passing through to toLat/toLon\n        if (![ 'd', 'dm', 'dms', 'n' ].includes(format)) throw new RangeError(`invalid format ‘${format}’`);\n\n        if (format == 'n') { // signed numeric degrees\n            if (dp == undefined) dp = 4;\n            return `${this.lat.toFixed(dp)},${this.lon.toFixed(dp)}`;\n        }\n        const lat = Dms.toLat(this.lat, format, dp);\n        const lon = Dms.toLon(this.lon, format, dp);\n        return `${lat}, ${lon}`;\n    }\n\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nexport { LatLonSpherical as default, Dms };\n"]},"metadata":{},"sourceType":"module"}