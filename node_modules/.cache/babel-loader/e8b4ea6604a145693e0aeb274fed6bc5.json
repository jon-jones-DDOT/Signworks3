{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar Accessor = require('../accessor');\n\nvar React = require('react');\n\nvar TypeaheadSelector = require('./selector');\n\nvar KeyEvent = require('../keyevent');\n\nvar fuzzy = require('fuzzy');\n\nvar classNames = require('classnames');\n\nvar createReactClass = require('create-react-class');\n\nvar PropTypes = require('prop-types');\n/**\n * A \"typeahead\", an auto-completing text input\n *\n * Renders an text input that shows options nearby that you can use the\n * keyboard or mouse to select.  Requires CSS for MASSIVE DAMAGE.\n */\n\n\nvar Typeahead = createReactClass({\n  displayName: 'Typeahead',\n  propTypes: {\n    name: PropTypes.string,\n    customClasses: PropTypes.object,\n    maxVisible: PropTypes.number,\n    resultsTruncatedMessage: PropTypes.string,\n    options: PropTypes.array,\n    allowCustomValues: PropTypes.number,\n    initialValue: PropTypes.string,\n    value: PropTypes.string,\n    placeholder: PropTypes.string,\n    disabled: PropTypes.bool,\n    textarea: PropTypes.bool,\n    inputProps: PropTypes.object,\n    onOptionSelected: PropTypes.func,\n    onChange: PropTypes.func,\n    onKeyDown: PropTypes.func,\n    onKeyPress: PropTypes.func,\n    onKeyUp: PropTypes.func,\n    onFocus: PropTypes.func,\n    onBlur: PropTypes.func,\n    filterOption: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),\n    searchOptions: PropTypes.func,\n    displayOption: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),\n    inputDisplayOption: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),\n    formInputOption: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),\n    defaultClassNames: PropTypes.bool,\n    customListComponent: PropTypes.oneOfType([PropTypes.element, PropTypes.func]),\n    showOptionsWhenEmpty: PropTypes.bool\n  },\n  getDefaultProps: function getDefaultProps() {\n    return {\n      options: [],\n      customClasses: {},\n      allowCustomValues: 0,\n      initialValue: \"\",\n      value: \"\",\n      placeholder: \"\",\n      disabled: false,\n      textarea: false,\n      inputProps: {},\n      onOptionSelected: function onOptionSelected(option) {},\n      onChange: function onChange(event) {},\n      onKeyDown: function onKeyDown(event) {},\n      onKeyPress: function onKeyPress(event) {},\n      onKeyUp: function onKeyUp(event) {},\n      onFocus: function onFocus(event) {},\n      onBlur: function onBlur(event) {},\n      filterOption: null,\n      searchOptions: null,\n      inputDisplayOption: null,\n      defaultClassNames: true,\n      customListComponent: TypeaheadSelector,\n      showOptionsWhenEmpty: false,\n      resultsTruncatedMessage: null\n    };\n  },\n  getInitialState: function getInitialState() {\n    return {\n      // The options matching the entry value\n      searchResults: this.getOptionsForValue(this.props.initialValue, this.props.options),\n      // This should be called something else, \"entryValue\"\n      entryValue: this.props.value || this.props.initialValue,\n      // A valid typeahead value\n      selection: this.props.value,\n      // Index of the selection\n      selectionIndex: null,\n      // Keep track of the focus state of the input element, to determine\n      // whether to show options when empty (if showOptionsWhenEmpty is true)\n      isFocused: false,\n      // true when focused, false onOptionSelected\n      showResults: false\n    };\n  },\n  _shouldSkipSearch: function _shouldSkipSearch(input) {\n    var emptyValue = !input || input.trim().length == 0; // this.state must be checked because it may not be defined yet if this function\n    // is called from within getInitialState\n\n    var isFocused = this.state && this.state.isFocused;\n    return !(this.props.showOptionsWhenEmpty && isFocused) && emptyValue;\n  },\n  getOptionsForValue: function getOptionsForValue(value, options) {\n    if (this._shouldSkipSearch(value)) {\n      return [];\n    }\n\n    var searchOptions = this._generateSearchFunction();\n\n    return searchOptions(value, options);\n  },\n  setEntryText: function setEntryText(value) {\n    this.refs.entry.value = value;\n\n    this._onTextEntryUpdated();\n  },\n  focus: function focus() {\n    this.refs.entry.focus();\n  },\n  _hasCustomValue: function _hasCustomValue() {\n    if (this.props.allowCustomValues > 0 && this.state.entryValue.length >= this.props.allowCustomValues && this.state.searchResults.indexOf(this.state.entryValue) < 0) {\n      return true;\n    }\n\n    return false;\n  },\n  _getCustomValue: function _getCustomValue() {\n    if (this._hasCustomValue()) {\n      return this.state.entryValue;\n    }\n\n    return null;\n  },\n  _renderIncrementalSearchResults: function _renderIncrementalSearchResults() {\n    // Nothing has been entered into the textbox\n    if (this._shouldSkipSearch(this.state.entryValue)) {\n      return \"\";\n    } // Something was just selected\n\n\n    if (this.state.selection) {\n      return \"\";\n    }\n\n    return React.createElement(this.props.customListComponent, {\n      ref: 'sel',\n      options: this.props.maxVisible ? this.state.searchResults.slice(0, this.props.maxVisible) : this.state.searchResults,\n      areResultsTruncated: this.props.maxVisible && this.state.searchResults.length > this.props.maxVisible,\n      resultsTruncatedMessage: this.props.resultsTruncatedMessage,\n      onOptionSelected: this._onOptionSelected,\n      allowCustomValues: this.props.allowCustomValues,\n      customValue: this._getCustomValue(),\n      customClasses: this.props.customClasses,\n      selectionIndex: this.state.selectionIndex,\n      defaultClassNames: this.props.defaultClassNames,\n      displayOption: Accessor.generateOptionToStringFor(this.props.displayOption)\n    });\n  },\n  getSelection: function getSelection() {\n    var index = this.state.selectionIndex;\n\n    if (this._hasCustomValue()) {\n      if (index === 0) {\n        return this.state.entryValue;\n      } else {\n        index--;\n      }\n    }\n\n    return this.state.searchResults[index];\n  },\n  _onOptionSelected: function _onOptionSelected(option, event) {\n    var nEntry = this.refs.entry;\n    nEntry.focus();\n    var displayOption = Accessor.generateOptionToStringFor(this.props.inputDisplayOption || this.props.displayOption);\n    var optionString = displayOption(option, 0);\n    var formInputOption = Accessor.generateOptionToStringFor(this.props.formInputOption || displayOption);\n    var formInputOptionString = formInputOption(option);\n    nEntry.value = optionString;\n    this.setState({\n      searchResults: this.getOptionsForValue(optionString, this.props.options),\n      selection: formInputOptionString,\n      entryValue: optionString,\n      showResults: false\n    });\n    return this.props.onOptionSelected(option, event);\n  },\n  _onTextEntryUpdated: function _onTextEntryUpdated() {\n    var value = this.refs.entry.value;\n    this.setState({\n      searchResults: this.getOptionsForValue(value, this.props.options),\n      selection: '',\n      entryValue: value\n    });\n  },\n  _onEnter: function _onEnter(event) {\n    var selection = this.getSelection();\n\n    if (!selection) {\n      return this.props.onKeyDown(event);\n    }\n\n    return this._onOptionSelected(selection, event);\n  },\n  _onEscape: function _onEscape() {\n    this.setState({\n      selectionIndex: null\n    });\n  },\n  _onTab: function _onTab(event) {\n    var selection = this.getSelection();\n    var option = selection ? selection : this.state.searchResults.length > 0 ? this.state.searchResults[0] : null;\n\n    if (option === null && this._hasCustomValue()) {\n      option = this._getCustomValue();\n    }\n\n    if (option !== null) {\n      return this._onOptionSelected(option, event);\n    }\n  },\n  eventMap: function eventMap(event) {\n    var events = {};\n    events[KeyEvent.DOM_VK_UP] = this.navUp;\n    events[KeyEvent.DOM_VK_DOWN] = this.navDown;\n    events[KeyEvent.DOM_VK_RETURN] = events[KeyEvent.DOM_VK_ENTER] = this._onEnter;\n    events[KeyEvent.DOM_VK_ESCAPE] = this._onEscape;\n    events[KeyEvent.DOM_VK_TAB] = this._onTab;\n    return events;\n  },\n  _nav: function _nav(delta) {\n    if (!this._hasHint()) {\n      return;\n    }\n\n    var newIndex = this.state.selectionIndex === null ? delta == 1 ? 0 : delta : this.state.selectionIndex + delta;\n    var length = this.props.maxVisible ? this.state.searchResults.slice(0, this.props.maxVisible).length : this.state.searchResults.length;\n\n    if (this._hasCustomValue()) {\n      length += 1;\n    }\n\n    if (newIndex < 0) {\n      newIndex += length;\n    } else if (newIndex >= length) {\n      newIndex -= length;\n    }\n\n    this.setState({\n      selectionIndex: newIndex\n    });\n  },\n  navDown: function navDown() {\n    this._nav(1);\n  },\n  navUp: function navUp() {\n    this._nav(-1);\n  },\n  _onChange: function _onChange(event) {\n    if (this.props.onChange) {\n      this.props.onChange(event);\n    }\n\n    this._onTextEntryUpdated();\n  },\n  _onKeyDown: function _onKeyDown(event) {\n    // If there are no visible elements, don't perform selector navigation.\n    // Just pass this up to the upstream onKeydown handler.\n    // Also skip if the user is pressing the shift key, since none of our handlers are looking for shift\n    if (!this._hasHint() || event.shiftKey) {\n      return this.props.onKeyDown(event);\n    }\n\n    var handler = this.eventMap()[event.keyCode];\n\n    if (handler) {\n      handler(event);\n    } else {\n      return this.props.onKeyDown(event);\n    } // Don't propagate the keystroke back to the DOM/browser\n\n\n    event.preventDefault();\n  },\n  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {\n    var searchResults = this.getOptionsForValue(this.state.entryValue, nextProps.options);\n    var showResults = Boolean(searchResults.length) && this.state.isFocused;\n    this.setState({\n      searchResults: searchResults,\n      showResults: showResults\n    });\n  },\n  render: function render() {\n    var inputClasses = {};\n    inputClasses[this.props.customClasses.input] = !!this.props.customClasses.input;\n    var inputClassList = classNames(inputClasses);\n    var classes = {\n      typeahead: this.props.defaultClassNames\n    };\n    classes[this.props.className] = !!this.props.className;\n    var classList = classNames(classes);\n    var InputElement = this.props.textarea ? 'textarea' : 'input';\n    return React.createElement('div', {\n      className: classList\n    }, this._renderHiddenInput(), React.createElement(InputElement, _extends({\n      ref: 'entry',\n      type: 'text',\n      disabled: this.props.disabled\n    }, this.props.inputProps, {\n      placeholder: this.props.placeholder,\n      className: inputClassList,\n      value: this.state.entryValue,\n      onChange: this._onChange,\n      onKeyDown: this._onKeyDown,\n      onKeyPress: this.props.onKeyPress,\n      onKeyUp: this.props.onKeyUp,\n      onFocus: this._onFocus,\n      onBlur: this._onBlur\n    })), this.state.showResults && this._renderIncrementalSearchResults());\n  },\n  _onFocus: function _onFocus(event) {\n    this.setState({\n      isFocused: true,\n      showResults: true\n    }, function () {\n      this._onTextEntryUpdated();\n    }.bind(this));\n\n    if (this.props.onFocus) {\n      return this.props.onFocus(event);\n    }\n  },\n  _onBlur: function _onBlur(event) {\n    this.setState({\n      isFocused: false\n    }, function () {\n      this._onTextEntryUpdated();\n    }.bind(this));\n\n    if (this.props.onBlur) {\n      return this.props.onBlur(event);\n    }\n  },\n  _renderHiddenInput: function _renderHiddenInput() {\n    if (!this.props.name) {\n      return null;\n    }\n\n    return React.createElement('input', {\n      type: 'hidden',\n      name: this.props.name,\n      value: this.state.selection\n    });\n  },\n  _generateSearchFunction: function _generateSearchFunction() {\n    var searchOptionsProp = this.props.searchOptions;\n    var filterOptionProp = this.props.filterOption;\n\n    if (typeof searchOptionsProp === 'function') {\n      if (filterOptionProp !== null) {\n        console.warn('searchOptions prop is being used, filterOption prop will be ignored');\n      }\n\n      return searchOptionsProp;\n    } else if (typeof filterOptionProp === 'function') {\n      return function (value, options) {\n        return options.filter(function (o) {\n          return filterOptionProp(value, o);\n        });\n      };\n    } else {\n      var mapper;\n\n      if (typeof filterOptionProp === 'string') {\n        mapper = Accessor.generateAccessor(filterOptionProp);\n      } else {\n        mapper = Accessor.IDENTITY_FN;\n      }\n\n      return function (value, options) {\n        return fuzzy.filter(value, options, {\n          extract: mapper\n        }).map(function (res) {\n          return options[res.index];\n        });\n      };\n    }\n  },\n  _hasHint: function _hasHint() {\n    return this.state.searchResults.length > 0 || this._hasCustomValue();\n  }\n});\nmodule.exports = Typeahead;","map":null,"metadata":{},"sourceType":"script"}