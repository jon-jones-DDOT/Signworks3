{"ast":null,"code":"/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n/* Latitude/longitude spherical geodesy tools                         (c) Chris Veness 2002-2017  */\n\n/*                                                                                   MIT Licence  */\n\n/* www.movable-type.co.uk/scripts/latlong.html                                                    */\n\n/* www.movable-type.co.uk/scripts/geodesy/docs/module-latlon-spherical.html                       */\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n'use strict';\n\nif (typeof module != 'undefined' && module.exports) var Dms = require('./dms'); // ≡ import Dms from 'dms.js'\n\n/**\r\n * Library of geodesy functions for operations on a spherical earth model.\r\n *\r\n * @module   latlon-spherical\r\n * @requires dms\r\n */\n\n/**\r\n * Creates a LatLon point on the earth's surface at the specified latitude / longitude.\r\n *\r\n * @constructor\r\n * @param {number} lat - Latitude in degrees.\r\n * @param {number} lon - Longitude in degrees.\r\n *\r\n * @example\r\n *     var p1 = new LatLon(52.205, 0.119);\r\n */\n\nfunction LatLon(lat, lon) {\n  // allow instantiation without 'new'\n  if (!(this instanceof LatLon)) return new LatLon(lat, lon);\n  this.lat = Number(lat);\n  this.lon = Number(lon);\n}\n/**\r\n * Returns the distance from ‘this’ point to destination point (using haversine formula).\r\n *\r\n * @param   {LatLon} point - Latitude/longitude of destination point.\r\n * @param   {number} [radius=6371e3] - (Mean) radius of earth (defaults to radius in metres).\r\n * @returns {number} Distance between this point and destination point, in same units as radius.\r\n *\r\n * @example\r\n *     var p1 = new LatLon(52.205, 0.119);\r\n *     var p2 = new LatLon(48.857, 2.351);\r\n *     var d = p1.distanceTo(p2); // 404.3 km\r\n */\n\n\nLatLon.prototype.distanceTo = function (point, radius) {\n  if (!(point instanceof LatLon)) throw new TypeError('point is not LatLon object');\n  radius = radius === undefined ? 6371e3 : Number(radius); // a = sin²(Δφ/2) + cos(φ1)⋅cos(φ2)⋅sin²(Δλ/2)\n  // tanδ = √(a) / √(1−a)\n  // see mathforum.org/library/drmath/view/51879.html for derivation\n\n  var R = radius;\n  var φ1 = this.lat.toRadians(),\n      λ1 = this.lon.toRadians();\n  var φ2 = point.lat.toRadians(),\n      λ2 = point.lon.toRadians();\n  var Δφ = φ2 - φ1;\n  var Δλ = λ2 - λ1;\n  var a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);\n  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  var d = R * c;\n  return d;\n};\n/**\r\n * Returns the (initial) bearing from ‘this’ point to destination point.\r\n *\r\n * @param   {LatLon} point - Latitude/longitude of destination point.\r\n * @returns {number} Initial bearing in degrees from north.\r\n *\r\n * @example\r\n *     var p1 = new LatLon(52.205, 0.119);\r\n *     var p2 = new LatLon(48.857, 2.351);\r\n *     var b1 = p1.bearingTo(p2); // 156.2°\r\n */\n\n\nLatLon.prototype.bearingTo = function (point) {\n  if (!(point instanceof LatLon)) throw new TypeError('point is not LatLon object'); // tanθ = sinΔλ⋅cosφ2 / cosφ1⋅sinφ2 − sinφ1⋅cosφ2⋅cosΔλ\n  // see mathforum.org/library/drmath/view/55417.html for derivation\n\n  var φ1 = this.lat.toRadians(),\n      φ2 = point.lat.toRadians();\n  var Δλ = (point.lon - this.lon).toRadians();\n  var y = Math.sin(Δλ) * Math.cos(φ2);\n  var x = Math.cos(φ1) * Math.sin(φ2) - Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);\n  var θ = Math.atan2(y, x);\n  return (θ.toDegrees() + 360) % 360;\n};\n/**\r\n * Returns final bearing arriving at destination destination point from ‘this’ point; the final bearing\r\n * will differ from the initial bearing by varying degrees according to distance and latitude.\r\n *\r\n * @param   {LatLon} point - Latitude/longitude of destination point.\r\n * @returns {number} Final bearing in degrees from north.\r\n *\r\n * @example\r\n *     var p1 = new LatLon(52.205, 0.119);\r\n *     var p2 = new LatLon(48.857, 2.351);\r\n *     var b2 = p1.finalBearingTo(p2); // 157.9°\r\n */\n\n\nLatLon.prototype.finalBearingTo = function (point) {\n  if (!(point instanceof LatLon)) throw new TypeError('point is not LatLon object'); // get initial bearing from destination point to this point & reverse it by adding 180°\n\n  return (point.bearingTo(this) + 180) % 360;\n};\n/**\r\n * Returns the midpoint between ‘this’ point and the supplied point.\r\n *\r\n * @param   {LatLon} point - Latitude/longitude of destination point.\r\n * @returns {LatLon} Midpoint between this point and the supplied point.\r\n *\r\n * @example\r\n *     var p1 = new LatLon(52.205, 0.119);\r\n *     var p2 = new LatLon(48.857, 2.351);\r\n *     var pMid = p1.midpointTo(p2); // 50.5363°N, 001.2746°E\r\n */\n\n\nLatLon.prototype.midpointTo = function (point) {\n  if (!(point instanceof LatLon)) throw new TypeError('point is not LatLon object'); // φm = atan2( sinφ1 + sinφ2, √( (cosφ1 + cosφ2⋅cosΔλ) ⋅ (cosφ1 + cosφ2⋅cosΔλ) ) + cos²φ2⋅sin²Δλ )\n  // λm = λ1 + atan2(cosφ2⋅sinΔλ, cosφ1 + cosφ2⋅cosΔλ)\n  // see mathforum.org/library/drmath/view/51822.html for derivation\n\n  var φ1 = this.lat.toRadians(),\n      λ1 = this.lon.toRadians();\n  var φ2 = point.lat.toRadians();\n  var Δλ = (point.lon - this.lon).toRadians();\n  var Bx = Math.cos(φ2) * Math.cos(Δλ);\n  var By = Math.cos(φ2) * Math.sin(Δλ);\n  var x = Math.sqrt((Math.cos(φ1) + Bx) * (Math.cos(φ1) + Bx) + By * By);\n  var y = Math.sin(φ1) + Math.sin(φ2);\n  var φ3 = Math.atan2(y, x);\n  var λ3 = λ1 + Math.atan2(By, Math.cos(φ1) + Bx);\n  return new LatLon(φ3.toDegrees(), (λ3.toDegrees() + 540) % 360 - 180); // normalise to −180..+180°\n};\n/**\r\n * Returns the point at given fraction between ‘this’ point and specified point.\r\n *\r\n * @param   {LatLon} point - Latitude/longitude of destination point.\r\n * @param   {number} fraction - Fraction between the two points (0 = this point, 1 = specified point).\r\n * @returns {LatLon} Intermediate point between this point and destination point.\r\n *\r\n * @example\r\n *   let p1 = new LatLon(52.205, 0.119);\r\n *   let p2 = new LatLon(48.857, 2.351);\r\n *   let pMid = p1.intermediatePointTo(p2, 0.25); // 51.3721°N, 000.7073°E\r\n */\n\n\nLatLon.prototype.intermediatePointTo = function (point, fraction) {\n  if (!(point instanceof LatLon)) throw new TypeError('point is not LatLon object');\n  var φ1 = this.lat.toRadians(),\n      λ1 = this.lon.toRadians();\n  var φ2 = point.lat.toRadians(),\n      λ2 = point.lon.toRadians();\n  var sinφ1 = Math.sin(φ1),\n      cosφ1 = Math.cos(φ1),\n      sinλ1 = Math.sin(λ1),\n      cosλ1 = Math.cos(λ1);\n  var sinφ2 = Math.sin(φ2),\n      cosφ2 = Math.cos(φ2),\n      sinλ2 = Math.sin(λ2),\n      cosλ2 = Math.cos(λ2); // distance between points\n\n  var Δφ = φ2 - φ1;\n  var Δλ = λ2 - λ1;\n  var a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);\n  var δ = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  var A = Math.sin((1 - fraction) * δ) / Math.sin(δ);\n  var B = Math.sin(fraction * δ) / Math.sin(δ);\n  var x = A * cosφ1 * cosλ1 + B * cosφ2 * cosλ2;\n  var y = A * cosφ1 * sinλ1 + B * cosφ2 * sinλ2;\n  var z = A * sinφ1 + B * sinφ2;\n  var φ3 = Math.atan2(z, Math.sqrt(x * x + y * y));\n  var λ3 = Math.atan2(y, x);\n  return new LatLon(φ3.toDegrees(), (λ3.toDegrees() + 540) % 360 - 180); // normalise lon to −180..+180°\n};\n/**\r\n * Returns the destination point from ‘this’ point having travelled the given distance on the\r\n * given initial bearing (bearing normally varies around path followed).\r\n *\r\n * @param   {number} distance - Distance travelled, in same units as earth radius (default: metres).\r\n * @param   {number} bearing - Initial bearing in degrees from north.\r\n * @param   {number} [radius=6371e3] - (Mean) radius of earth (defaults to radius in metres).\r\n * @returns {LatLon} Destination point.\r\n *\r\n * @example\r\n *     var p1 = new LatLon(51.4778, -0.0015);\r\n *     var p2 = p1.destinationPoint(7794, 300.7); // 51.5135°N, 000.0983°W\r\n */\n\n\nLatLon.prototype.destinationPoint = function (distance, bearing, radius) {\n  radius = radius === undefined ? 6371e3 : Number(radius); // sinφ2 = sinφ1⋅cosδ + cosφ1⋅sinδ⋅cosθ\n  // tanΔλ = sinθ⋅sinδ⋅cosφ1 / cosδ−sinφ1⋅sinφ2\n  // see mathforum.org/library/drmath/view/52049.html for derivation\n\n  var δ = Number(distance) / radius; // angular distance in radians\n\n  var θ = Number(bearing).toRadians();\n  var φ1 = this.lat.toRadians();\n  var λ1 = this.lon.toRadians();\n  var sinφ1 = Math.sin(φ1),\n      cosφ1 = Math.cos(φ1);\n  var sinδ = Math.sin(δ),\n      cosδ = Math.cos(δ);\n  var sinθ = Math.sin(θ),\n      cosθ = Math.cos(θ);\n  var sinφ2 = sinφ1 * cosδ + cosφ1 * sinδ * cosθ;\n  var φ2 = Math.asin(sinφ2);\n  var y = sinθ * sinδ * cosφ1;\n  var x = cosδ - sinφ1 * sinφ2;\n  var λ2 = λ1 + Math.atan2(y, x);\n  return new LatLon(φ2.toDegrees(), (λ2.toDegrees() + 540) % 360 - 180); // normalise to −180..+180°\n};\n/**\r\n * Returns the point of intersection of two paths defined by point and bearing.\r\n *\r\n * @param   {LatLon} p1 - First point.\r\n * @param   {number} brng1 - Initial bearing from first point.\r\n * @param   {LatLon} p2 - Second point.\r\n * @param   {number} brng2 - Initial bearing from second point.\r\n * @returns {LatLon|null} Destination point (null if no unique intersection defined).\r\n *\r\n * @example\r\n *     var p1 = LatLon(51.8853, 0.2545), brng1 = 108.547;\r\n *     var p2 = LatLon(49.0034, 2.5735), brng2 =  32.435;\r\n *     var pInt = LatLon.intersection(p1, brng1, p2, brng2); // 50.9078°N, 004.5084°E\r\n */\n\n\nLatLon.intersection = function (p1, brng1, p2, brng2) {\n  if (!(p1 instanceof LatLon)) throw new TypeError('p1 is not LatLon object');\n  if (!(p2 instanceof LatLon)) throw new TypeError('p2 is not LatLon object'); // see www.edwilliams.org/avform.htm#Intersection\n\n  var φ1 = p1.lat.toRadians(),\n      λ1 = p1.lon.toRadians();\n  var φ2 = p2.lat.toRadians(),\n      λ2 = p2.lon.toRadians();\n  var θ13 = Number(brng1).toRadians(),\n      θ23 = Number(brng2).toRadians();\n  var Δφ = φ2 - φ1,\n      Δλ = λ2 - λ1; // angular distance p1-p2\n\n  var δ12 = 2 * Math.asin(Math.sqrt(Math.sin(Δφ / 2) * Math.sin(Δφ / 2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2)));\n  if (δ12 == 0) return null; // initial/final bearings between points\n\n  var θa = Math.acos((Math.sin(φ2) - Math.sin(φ1) * Math.cos(δ12)) / (Math.sin(δ12) * Math.cos(φ1)));\n  if (isNaN(θa)) θa = 0; // protect against rounding\n\n  var θb = Math.acos((Math.sin(φ1) - Math.sin(φ2) * Math.cos(δ12)) / (Math.sin(δ12) * Math.cos(φ2)));\n  var θ12 = Math.sin(λ2 - λ1) > 0 ? θa : 2 * Math.PI - θa;\n  var θ21 = Math.sin(λ2 - λ1) > 0 ? 2 * Math.PI - θb : θb;\n  var α1 = θ13 - θ12; // angle 2-1-3\n\n  var α2 = θ21 - θ23; // angle 1-2-3\n\n  if (Math.sin(α1) == 0 && Math.sin(α2) == 0) return null; // infinite intersections\n\n  if (Math.sin(α1) * Math.sin(α2) < 0) return null; // ambiguous intersection\n\n  var α3 = Math.acos(-Math.cos(α1) * Math.cos(α2) + Math.sin(α1) * Math.sin(α2) * Math.cos(δ12));\n  var δ13 = Math.atan2(Math.sin(δ12) * Math.sin(α1) * Math.sin(α2), Math.cos(α2) + Math.cos(α1) * Math.cos(α3));\n  var φ3 = Math.asin(Math.sin(φ1) * Math.cos(δ13) + Math.cos(φ1) * Math.sin(δ13) * Math.cos(θ13));\n  var Δλ13 = Math.atan2(Math.sin(θ13) * Math.sin(δ13) * Math.cos(φ1), Math.cos(δ13) - Math.sin(φ1) * Math.sin(φ3));\n  var λ3 = λ1 + Δλ13;\n  return new LatLon(φ3.toDegrees(), (λ3.toDegrees() + 540) % 360 - 180); // normalise to −180..+180°\n};\n/**\r\n * Returns (signed) distance from ‘this’ point to great circle defined by start-point and end-point.\r\n *\r\n * @param   {LatLon} pathStart - Start point of great circle path.\r\n * @param   {LatLon} pathEnd - End point of great circle path.\r\n * @param   {number} [radius=6371e3] - (Mean) radius of earth (defaults to radius in metres).\r\n * @returns {number} Distance to great circle (-ve if to left, +ve if to right of path).\r\n *\r\n * @example\r\n *   var pCurrent = new LatLon(53.2611, -0.7972);\r\n *   var p1 = new LatLon(53.3206, -1.7297);\r\n *   var p2 = new LatLon(53.1887,  0.1334);\r\n *   var d = pCurrent.crossTrackDistanceTo(p1, p2);  // -307.5 m\r\n */\n\n\nLatLon.prototype.crossTrackDistanceTo = function (pathStart, pathEnd, radius) {\n  if (!(pathStart instanceof LatLon)) throw new TypeError('pathStart is not LatLon object');\n  if (!(pathEnd instanceof LatLon)) throw new TypeError('pathEnd is not LatLon object');\n  var R = radius === undefined ? 6371e3 : Number(radius);\n  var δ13 = pathStart.distanceTo(this, R) / R;\n  var θ13 = pathStart.bearingTo(this).toRadians();\n  var θ12 = pathStart.bearingTo(pathEnd).toRadians();\n  var δxt = Math.asin(Math.sin(δ13) * Math.sin(θ13 - θ12));\n  return δxt * R;\n};\n/**\r\n * Returns how far ‘this’ point is along a path from from start-point, heading towards end-point.\r\n * That is, if a perpendicular is drawn from ‘this’ point to the (great circle) path, the along-track\r\n * distance is the distance from the start point to where the perpendicular crosses the path.\r\n *\r\n * @param   {LatLon} pathStart - Start point of great circle path.\r\n * @param   {LatLon} pathEnd - End point of great circle path.\r\n * @param   {number} [radius=6371e3] - (Mean) radius of earth (defaults to radius in metres).\r\n * @returns {number} Distance along great circle to point nearest ‘this’ point.\r\n *\r\n * @example\r\n *   var pCurrent = new LatLon(53.2611, -0.7972);\r\n *   var p1 = new LatLon(53.3206, -1.7297);\r\n *   var p2 = new LatLon(53.1887,  0.1334);\r\n *   var d = pCurrent.alongTrackDistanceTo(p1, p2);  // 62.331 km\r\n */\n\n\nLatLon.prototype.alongTrackDistanceTo = function (pathStart, pathEnd, radius) {\n  if (!(pathStart instanceof LatLon)) throw new TypeError('pathStart is not LatLon object');\n  if (!(pathEnd instanceof LatLon)) throw new TypeError('pathEnd is not LatLon object');\n  var R = radius === undefined ? 6371e3 : Number(radius);\n  var δ13 = pathStart.distanceTo(this, R) / R;\n  var θ13 = pathStart.bearingTo(this).toRadians();\n  var θ12 = pathStart.bearingTo(pathEnd).toRadians();\n  var δxt = Math.asin(Math.sin(δ13) * Math.sin(θ13 - θ12));\n  var δat = Math.acos(Math.cos(δ13) / Math.abs(Math.cos(δxt)));\n  return δat * Math.sign(Math.cos(θ12 - θ13)) * R;\n};\n/**\r\n * Returns maximum latitude reached when travelling on a great circle on given bearing from this\r\n * point ('Clairaut's formula'). Negate the result for the minimum latitude (in the Southern\r\n * hemisphere).\r\n *\r\n * The maximum latitude is independent of longitude; it will be the same for all points on a given\r\n * latitude.\r\n *\r\n * @param {number} bearing - Initial bearing.\r\n * @param {number} latitude - Starting latitude.\r\n */\n\n\nLatLon.prototype.maxLatitude = function (bearing) {\n  var θ = Number(bearing).toRadians();\n  var φ = this.lat.toRadians();\n  var φMax = Math.acos(Math.abs(Math.sin(θ) * Math.cos(φ)));\n  return φMax.toDegrees();\n};\n/**\r\n * Returns the pair of meridians at which a great circle defined by two points crosses the given\r\n * latitude. If the great circle doesn't reach the given latitude, null is returned.\r\n *\r\n * @param {LatLon} point1 - First point defining great circle.\r\n * @param {LatLon} point2 - Second point defining great circle.\r\n * @param {number} latitude - Latitude crossings are to be determined for.\r\n * @returns {Object|null} Object containing { lon1, lon2 } or null if given latitude not reached.\r\n */\n\n\nLatLon.crossingParallels = function (point1, point2, latitude) {\n  var φ = Number(latitude).toRadians();\n  var φ1 = point1.lat.toRadians();\n  var λ1 = point1.lon.toRadians();\n  var φ2 = point2.lat.toRadians();\n  var λ2 = point2.lon.toRadians();\n  var Δλ = λ2 - λ1;\n  var x = Math.sin(φ1) * Math.cos(φ2) * Math.cos(φ) * Math.sin(Δλ);\n  var y = Math.sin(φ1) * Math.cos(φ2) * Math.cos(φ) * Math.cos(Δλ) - Math.cos(φ1) * Math.sin(φ2) * Math.cos(φ);\n  var z = Math.cos(φ1) * Math.cos(φ2) * Math.sin(φ) * Math.sin(Δλ);\n  if (z * z > x * x + y * y) return null; // great circle doesn't reach latitude\n\n  var λm = Math.atan2(-y, x); // longitude at max latitude\n\n  var Δλi = Math.acos(z / Math.sqrt(x * x + y * y)); // Δλ from λm to intersection points\n\n  var λi1 = λ1 + λm - Δλi;\n  var λi2 = λ1 + λm + Δλi;\n  return {\n    lon1: (λi1.toDegrees() + 540) % 360 - 180,\n    lon2: (λi2.toDegrees() + 540) % 360 - 180\n  }; // normalise to −180..+180°\n};\n/* Rhumb - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n/**\r\n * Returns the distance travelling from ‘this’ point to destination point along a rhumb line.\r\n *\r\n * @param   {LatLon} point - Latitude/longitude of destination point.\r\n * @param   {number} [radius=6371e3] - (Mean) radius of earth (defaults to radius in metres).\r\n * @returns {number} Distance in km between this point and destination point (same units as radius).\r\n *\r\n * @example\r\n *     var p1 = new LatLon(51.127, 1.338);\r\n *     var p2 = new LatLon(50.964, 1.853);\r\n *     var d = p1.distanceTo(p2); // 40.31 km\r\n */\n\n\nLatLon.prototype.rhumbDistanceTo = function (point, radius) {\n  if (!(point instanceof LatLon)) throw new TypeError('point is not LatLon object');\n  radius = radius === undefined ? 6371e3 : Number(radius); // see www.edwilliams.org/avform.htm#Rhumb\n\n  var R = radius;\n  var φ1 = this.lat.toRadians(),\n      φ2 = point.lat.toRadians();\n  var Δφ = φ2 - φ1;\n  var Δλ = Math.abs(point.lon - this.lon).toRadians(); // if dLon over 180° take shorter rhumb line across the anti-meridian:\n\n  if (Δλ > Math.PI) Δλ -= 2 * Math.PI; // on Mercator projection, longitude distances shrink by latitude; q is the 'stretch factor'\n  // q becomes ill-conditioned along E-W line (0/0); use empirical tolerance to avoid it\n\n  var Δψ = Math.log(Math.tan(φ2 / 2 + Math.PI / 4) / Math.tan(φ1 / 2 + Math.PI / 4));\n  var q = Math.abs(Δψ) > 10e-12 ? Δφ / Δψ : Math.cos(φ1); // distance is pythagoras on 'stretched' Mercator projection\n\n  var δ = Math.sqrt(Δφ * Δφ + q * q * Δλ * Δλ); // angular distance in radians\n\n  var dist = δ * R;\n  return dist;\n};\n/**\r\n * Returns the bearing from ‘this’ point to destination point along a rhumb line.\r\n *\r\n * @param   {LatLon} point - Latitude/longitude of destination point.\r\n * @returns {number} Bearing in degrees from north.\r\n *\r\n * @example\r\n *     var p1 = new LatLon(51.127, 1.338);\r\n *     var p2 = new LatLon(50.964, 1.853);\r\n *     var d = p1.rhumbBearingTo(p2); // 116.7 m\r\n */\n\n\nLatLon.prototype.rhumbBearingTo = function (point) {\n  if (!(point instanceof LatLon)) throw new TypeError('point is not LatLon object');\n  var φ1 = this.lat.toRadians(),\n      φ2 = point.lat.toRadians();\n  var Δλ = (point.lon - this.lon).toRadians(); // if dLon over 180° take shorter rhumb line across the anti-meridian:\n\n  if (Δλ > Math.PI) Δλ -= 2 * Math.PI;\n  if (Δλ < -Math.PI) Δλ += 2 * Math.PI;\n  var Δψ = Math.log(Math.tan(φ2 / 2 + Math.PI / 4) / Math.tan(φ1 / 2 + Math.PI / 4));\n  var θ = Math.atan2(Δλ, Δψ);\n  return (θ.toDegrees() + 360) % 360;\n};\n/**\r\n * Returns the destination point having travelled along a rhumb line from ‘this’ point the given\r\n * distance on the  given bearing.\r\n *\r\n * @param   {number} distance - Distance travelled, in same units as earth radius (default: metres).\r\n * @param   {number} bearing - Bearing in degrees from north.\r\n * @param   {number} [radius=6371e3] - (Mean) radius of earth (defaults to radius in metres).\r\n * @returns {LatLon} Destination point.\r\n *\r\n * @example\r\n *     var p1 = new LatLon(51.127, 1.338);\r\n *     var p2 = p1.rhumbDestinationPoint(40300, 116.7); // 50.9642°N, 001.8530°E\r\n */\n\n\nLatLon.prototype.rhumbDestinationPoint = function (distance, bearing, radius) {\n  radius = radius === undefined ? 6371e3 : Number(radius);\n  var δ = Number(distance) / radius; // angular distance in radians\n\n  var φ1 = this.lat.toRadians(),\n      λ1 = this.lon.toRadians();\n  var θ = Number(bearing).toRadians();\n  var Δφ = δ * Math.cos(θ);\n  var φ2 = φ1 + Δφ; // check for some daft bugger going past the pole, normalise latitude if so\n\n  if (Math.abs(φ2) > Math.PI / 2) φ2 = φ2 > 0 ? Math.PI - φ2 : -Math.PI - φ2;\n  var Δψ = Math.log(Math.tan(φ2 / 2 + Math.PI / 4) / Math.tan(φ1 / 2 + Math.PI / 4));\n  var q = Math.abs(Δψ) > 10e-12 ? Δφ / Δψ : Math.cos(φ1); // E-W course becomes ill-conditioned with 0/0\n\n  var Δλ = δ * Math.sin(θ) / q;\n  var λ2 = λ1 + Δλ;\n  return new LatLon(φ2.toDegrees(), (λ2.toDegrees() + 540) % 360 - 180); // normalise to −180..+180°\n};\n/**\r\n * Returns the loxodromic midpoint (along a rhumb line) between ‘this’ point and second point.\r\n *\r\n * @param   {LatLon} point - Latitude/longitude of second point.\r\n * @returns {LatLon} Midpoint between this point and second point.\r\n *\r\n * @example\r\n *     var p1 = new LatLon(51.127, 1.338);\r\n *     var p2 = new LatLon(50.964, 1.853);\r\n *     var pMid = p1.rhumbMidpointTo(p2); // 51.0455°N, 001.5957°E\r\n */\n\n\nLatLon.prototype.rhumbMidpointTo = function (point) {\n  if (!(point instanceof LatLon)) throw new TypeError('point is not LatLon object'); // see mathforum.org/kb/message.jspa?messageID=148837\n\n  var φ1 = this.lat.toRadians(),\n      λ1 = this.lon.toRadians();\n  var φ2 = point.lat.toRadians(),\n      λ2 = point.lon.toRadians();\n  if (Math.abs(λ2 - λ1) > Math.PI) λ1 += 2 * Math.PI; // crossing anti-meridian\n\n  var φ3 = (φ1 + φ2) / 2;\n  var f1 = Math.tan(Math.PI / 4 + φ1 / 2);\n  var f2 = Math.tan(Math.PI / 4 + φ2 / 2);\n  var f3 = Math.tan(Math.PI / 4 + φ3 / 2);\n  var λ3 = ((λ2 - λ1) * Math.log(f3) + λ1 * Math.log(f2) - λ2 * Math.log(f1)) / Math.log(f2 / f1);\n  if (!isFinite(λ3)) λ3 = (λ1 + λ2) / 2; // parallel of latitude\n\n  var p = LatLon(φ3.toDegrees(), (λ3.toDegrees() + 540) % 360 - 180); // normalise to −180..+180°\n\n  return p;\n};\n/* Area - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n/**\r\n * Calculates the area of a spherical polygon where the sides of the polygon are great circle\r\n * arcs joining the vertices.\r\n *\r\n * @param   {LatLon[]} polygon - Array of points defining vertices of the polygon\r\n * @param   {number} [radius=6371e3] - (Mean) radius of earth (defaults to radius in metres).\r\n * @returns {number} The area of the polygon, in the same units as radius.\r\n *\r\n * @example\r\n *   var polygon = [new LatLon(0,0), new LatLon(1,0), new LatLon(0,1)];\r\n *   var area = LatLon.areaOf(polygon); // 6.18e9 m²\r\n */\n\n\nLatLon.areaOf = function (polygon, radius) {\n  // uses method due to Karney: osgeo-org.1560.x6.nabble.com/Area-of-a-spherical-polygon-td3841625.html;\n  // for each edge of the polygon, tan(E/2) = tan(Δλ/2)·(tan(φ1/2) + tan(φ2/2)) / (1 + tan(φ1/2)·tan(φ2/2))\n  // where E is the spherical excess of the trapezium obtained by extending the edge to the equator\n  var R = radius === undefined ? 6371e3 : Number(radius); // close polygon so that last point equals first point\n\n  var closed = polygon[0].equals(polygon[polygon.length - 1]);\n  if (!closed) polygon.push(polygon[0]);\n  var nVertices = polygon.length - 1;\n  var S = 0; // spherical excess in steradians\n\n  for (var v = 0; v < nVertices; v++) {\n    var φ1 = polygon[v].lat.toRadians();\n    var φ2 = polygon[v + 1].lat.toRadians();\n    var Δλ = (polygon[v + 1].lon - polygon[v].lon).toRadians();\n    var E = 2 * Math.atan2(Math.tan(Δλ / 2) * (Math.tan(φ1 / 2) + Math.tan(φ2 / 2)), 1 + Math.tan(φ1 / 2) * Math.tan(φ2 / 2));\n    S += E;\n  }\n\n  if (isPoleEnclosedBy(polygon)) S = Math.abs(S) - 2 * Math.PI;\n  var A = Math.abs(S * R * R); // area in units of R\n\n  if (!closed) polygon.pop(); // restore polygon to pristine condition\n\n  return A; // returns whether polygon encloses pole: sum of course deltas around pole is 0° rather than\n  // normal ±360°: blog.element84.com/determining-if-a-spherical-polygon-contains-a-pole.html\n\n  function isPoleEnclosedBy(polygon) {\n    // TODO: any better test than this?\n    var ΣΔ = 0;\n    var prevBrng = polygon[0].bearingTo(polygon[1]);\n\n    for (var v = 0; v < polygon.length - 1; v++) {\n      var initBrng = polygon[v].bearingTo(polygon[v + 1]);\n      var finalBrng = polygon[v].finalBearingTo(polygon[v + 1]);\n      ΣΔ += (initBrng - prevBrng + 540) % 360 - 180;\n      ΣΔ += (finalBrng - initBrng + 540) % 360 - 180;\n      prevBrng = finalBrng;\n    }\n\n    var initBrng = polygon[0].bearingTo(polygon[1]);\n    ΣΔ += (initBrng - prevBrng + 540) % 360 - 180; // TODO: fix (intermittant) edge crossing pole - eg (85,90), (85,0), (85,-90)\n\n    var enclosed = Math.abs(ΣΔ) < 90; // 0°-ish\n\n    return enclosed;\n  }\n};\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n/**\r\n * Checks if another point is equal to ‘this’ point.\r\n *\r\n * @param   {LatLon} point - Point to be compared against this point.\r\n * @returns {bool}   True if points are identical.\r\n *\r\n * @example\r\n *   var p1 = new LatLon(52.205, 0.119);\r\n *   var p2 = new LatLon(52.205, 0.119);\r\n *   var equal = p1.equals(p2); // true\r\n */\n\n\nLatLon.prototype.equals = function (point) {\n  if (!(point instanceof LatLon)) throw new TypeError('point is not LatLon object');\n  if (this.lat != point.lat) return false;\n  if (this.lon != point.lon) return false;\n  return true;\n};\n/**\r\n * Returns a string representation of ‘this’ point, formatted as degrees, degrees+minutes, or\r\n * degrees+minutes+seconds.\r\n *\r\n * @param   {string} [format=dms] - Format point as 'd', 'dm', 'dms'.\r\n * @param   {number} [dp=0|2|4] - Number of decimal places to use - default 0 for dms, 2 for dm, 4 for d.\r\n * @returns {string} Comma-separated latitude/longitude.\r\n */\n\n\nLatLon.prototype.toString = function (format, dp) {\n  return Dms.toLat(this.lat, format, dp) + ', ' + Dms.toLon(this.lon, format, dp);\n};\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n/** Extend Number object with method to convert numeric degrees to radians */\n\n\nif (Number.prototype.toRadians === undefined) {\n  Number.prototype.toRadians = function () {\n    return this * Math.PI / 180;\n  };\n}\n/** Extend Number object with method to convert radians to numeric (signed) degrees */\n\n\nif (Number.prototype.toDegrees === undefined) {\n  Number.prototype.toDegrees = function () {\n    return this * 180 / Math.PI;\n  };\n}\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n\nif (typeof module != 'undefined' && module.exports) module.exports = LatLon; // ≡ export default LatLon\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n/* Geodesy representation conversion functions                        (c) Chris Veness 2002-2017  */\n\n/*                                                                                   MIT Licence  */\n\n/* www.movable-type.co.uk/scripts/latlong.html                                                    */\n\n/* www.movable-type.co.uk/scripts/geodesy/docs/module-dms.html                                    */\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n'use strict';\n/* eslint no-irregular-whitespace: [2, { skipComments: true }] */\n\n/**\r\n * Latitude/longitude points may be represented as decimal degrees, or subdivided into sexagesimal\r\n * minutes and seconds.\r\n *\r\n * @module dms\r\n */\n\n/**\r\n * Functions for parsing and representing degrees / minutes / seconds.\r\n * @class Dms\r\n */\n\n\nvar Dms = {}; // note Unicode Degree = U+00B0. Prime = U+2032, Double prime = U+2033\n\n/**\r\n * Parses string representing degrees/minutes/seconds into numeric degrees.\r\n *\r\n * This is very flexible on formats, allowing signed decimal degrees, or deg-min-sec optionally\r\n * suffixed by compass direction (NSEW). A variety of separators are accepted (eg 3° 37′ 09″W).\r\n * Seconds and minutes may be omitted.\r\n *\r\n * @param   {string|number} dmsStr - Degrees or deg/min/sec in variety of formats.\r\n * @returns {number} Degrees as decimal number.\r\n *\r\n * @example\r\n *     var lat = Dms.parseDMS('51° 28′ 40.12″ N');\r\n *     var lon = Dms.parseDMS('000° 00′ 05.31″ W');\r\n *     var p1 = new LatLon(lat, lon); // 51.4778°N, 000.0015°W\r\n */\n\nDms.parseDMS = function (dmsStr) {\n  // check for signed decimal degrees without NSEW, if so return it directly\n  if (typeof dmsStr == 'number' && isFinite(dmsStr)) return Number(dmsStr); // strip off any sign or compass dir'n & split out separate d/m/s\n\n  var dms = String(dmsStr).trim().replace(/^-/, '').replace(/[NSEW]$/i, '').split(/[^0-9.,]+/);\n  if (dms[dms.length - 1] == '') dms.splice(dms.length - 1); // from trailing symbol\n\n  if (dms == '') return NaN; // and convert to decimal degrees...\n\n  var deg;\n\n  switch (dms.length) {\n    case 3:\n      // interpret 3-part result as d/m/s\n      deg = dms[0] / 1 + dms[1] / 60 + dms[2] / 3600;\n      break;\n\n    case 2:\n      // interpret 2-part result as d/m\n      deg = dms[0] / 1 + dms[1] / 60;\n      break;\n\n    case 1:\n      // just d (possibly decimal) or non-separated dddmmss\n      deg = dms[0]; // check for fixed-width unseparated format eg 0033709W\n      //if (/[NS]/i.test(dmsStr)) deg = '0' + deg;  // - normalise N/S to 3-digit degrees\n      //if (/[0-9]{7}/.test(deg)) deg = deg.slice(0,3)/1 + deg.slice(3,5)/60 + deg.slice(5)/3600;\n\n      break;\n\n    default:\n      return NaN;\n  }\n\n  if (/^-|[WS]$/i.test(dmsStr.trim())) deg = -deg; // take '-', west and south as -ve\n\n  return Number(deg);\n};\n/**\r\n * Separator character to be used to separate degrees, minutes, seconds, and cardinal directions.\r\n *\r\n * Set to '\\u202f' (narrow no-break space) for improved formatting.\r\n *\r\n * @example\r\n *   var p = new LatLon(51.2, 0.33);  // 51°12′00.0″N, 000°19′48.0″E\r\n *   Dms.separator = '\\u202f';        // narrow no-break space\r\n *   var pʹ = new LatLon(51.2, 0.33); // 51° 12′ 00.0″ N, 000° 19′ 48.0″ E\r\n */\n\n\nDms.separator = '';\n/**\r\n * Converts decimal degrees to deg/min/sec format\r\n *  - degree, prime, double-prime symbols are added, but sign is discarded, though no compass\r\n *    direction is added.\r\n *\r\n * @private\r\n * @param   {number} deg - Degrees to be formatted as specified.\r\n * @param   {string} [format=dms] - Return value as 'd', 'dm', 'dms' for deg, deg+min, deg+min+sec.\r\n * @param   {number} [dp=0|2|4] - Number of decimal places to use – default 0 for dms, 2 for dm, 4 for d.\r\n * @returns {string} Degrees formatted as deg/min/secs according to specified format.\r\n */\n\nDms.toDMS = function (deg, format, dp) {\n  if (isNaN(deg)) return null; // give up here if we can't make a number from deg\n  // default values\n\n  if (format === undefined) format = 'dms';\n\n  if (dp === undefined) {\n    switch (format) {\n      case 'd':\n      case 'deg':\n        dp = 4;\n        break;\n\n      case 'dm':\n      case 'deg+min':\n        dp = 2;\n        break;\n\n      case 'dms':\n      case 'deg+min+sec':\n        dp = 0;\n        break;\n\n      default:\n        format = 'dms';\n        dp = 0;\n      // be forgiving on invalid format\n    }\n  }\n\n  deg = Math.abs(deg); // (unsigned result ready for appending compass dir'n)\n\n  var dms, d, m, s;\n\n  switch (format) {\n    default: // invalid format spec!\n\n    case 'd':\n    case 'deg':\n      d = deg.toFixed(dp); // round/right-pad degrees\n\n      if (d < 100) d = '0' + d; // left-pad with leading zeros (note may include decimals)\n\n      if (d < 10) d = '0' + d;\n      dms = d + '°';\n      break;\n\n    case 'dm':\n    case 'deg+min':\n      d = Math.floor(deg); // get component deg\n\n      m = (deg * 60 % 60).toFixed(dp); // get component min & round/right-pad\n\n      if (m == 60) {\n        m = 0;\n        d++;\n      } // check for rounding up\n\n\n      d = ('000' + d).slice(-3); // left-pad with leading zeros\n\n      if (m < 10) m = '0' + m; // left-pad with leading zeros (note may include decimals)\n\n      dms = d + '°' + Dms.separator + m + '′';\n      break;\n\n    case 'dms':\n    case 'deg+min+sec':\n      d = Math.floor(deg); // get component deg\n\n      m = Math.floor(deg * 3600 / 60) % 60; // get component min\n\n      s = (deg * 3600 % 60).toFixed(dp); // get component sec & round/right-pad\n\n      if (s == 60) {\n        s = 0 .toFixed(dp);\n        m++;\n      } // check for rounding up\n\n\n      if (m == 60) {\n        m = 0;\n        d++;\n      } // check for rounding up\n\n\n      d = ('000' + d).slice(-3); // left-pad with leading zeros\n\n      m = ('00' + m).slice(-2); // left-pad with leading zeros\n\n      if (s < 10) s = '0' + s; // left-pad with leading zeros (note may include decimals)\n\n      dms = d + '°' + Dms.separator + m + '′' + Dms.separator + s + '″';\n      break;\n  }\n\n  return dms;\n};\n/**\r\n * Converts numeric degrees to deg/min/sec latitude (2-digit degrees, suffixed with N/S).\r\n *\r\n * @param   {number} deg - Degrees to be formatted as specified.\r\n * @param   {string} [format=dms] - Return value as 'd', 'dm', 'dms' for deg, deg+min, deg+min+sec.\r\n * @param   {number} [dp=0|2|4] - Number of decimal places to use – default 0 for dms, 2 for dm, 4 for d.\r\n * @returns {string} Degrees formatted as deg/min/secs according to specified format.\r\n */\n\n\nDms.toLat = function (deg, format, dp) {\n  var lat = Dms.toDMS(deg, format, dp);\n  return lat === null ? '–' : lat.slice(1) + Dms.separator + (deg < 0 ? 'S' : 'N'); // knock off initial '0' for lat!\n};\n/**\r\n * Convert numeric degrees to deg/min/sec longitude (3-digit degrees, suffixed with E/W)\r\n *\r\n * @param   {number} deg - Degrees to be formatted as specified.\r\n * @param   {string} [format=dms] - Return value as 'd', 'dm', 'dms' for deg, deg+min, deg+min+sec.\r\n * @param   {number} [dp=0|2|4] - Number of decimal places to use – default 0 for dms, 2 for dm, 4 for d.\r\n * @returns {string} Degrees formatted as deg/min/secs according to specified format.\r\n */\n\n\nDms.toLon = function (deg, format, dp) {\n  var lon = Dms.toDMS(deg, format, dp);\n  return lon === null ? '–' : lon + Dms.separator + (deg < 0 ? 'W' : 'E');\n};\n/**\r\n * Converts numeric degrees to deg/min/sec as a bearing (0°..360°)\r\n *\r\n * @param   {number} deg - Degrees to be formatted as specified.\r\n * @param   {string} [format=dms] - Return value as 'd', 'dm', 'dms' for deg, deg+min, deg+min+sec.\r\n * @param   {number} [dp=0|2|4] - Number of decimal places to use – default 0 for dms, 2 for dm, 4 for d.\r\n * @returns {string} Degrees formatted as deg/min/secs according to specified format.\r\n */\n\n\nDms.toBrng = function (deg, format, dp) {\n  deg = (Number(deg) + 360) % 360; // normalise -ve values to 180°..360°\n\n  var brng = Dms.toDMS(deg, format, dp);\n  return brng === null ? '–' : brng.replace('360', '0'); // just in case rounding took us up to 360°!\n};\n/**\r\n * Returns compass point (to given precision) for supplied bearing.\r\n *\r\n * @param   {number} bearing - Bearing in degrees from north.\r\n * @param   {number} [precision=3] - Precision (1:cardinal / 2:intercardinal / 3:secondary-intercardinal).\r\n * @returns {string} Compass point for supplied bearing.\r\n *\r\n * @example\r\n *   var point = Dms.compassPoint(24);    // point = 'NNE'\r\n *   var point = Dms.compassPoint(24, 1); // point = 'N'\r\n */\n\n\nDms.compassPoint = function (bearing, precision) {\n  if (precision === undefined) precision = 3; // note precision could be extended to 4 for quarter-winds (eg NbNW), but I think they are little used\n\n  bearing = (bearing % 360 + 360) % 360; // normalise to range 0..360°\n\n  var cardinals = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];\n  var n = 4 * Math.pow(2, precision - 1); // no of compass points at req’d precision (1=>4, 2=>8, 3=>16)\n\n  var cardinal = cardinals[Math.round(bearing * n / 360) % n * 16 / n];\n  return cardinal;\n};\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n\nif (typeof module != 'undefined' && module.exports) module.exports = Dms; // ≡ export default Dms","map":{"version":3,"sources":["C:\\Projects\\Signworks3\\src\\utils\\GeodesyTools.js"],"names":["module","exports","Dms","require","LatLon","lat","lon","Number","prototype","distanceTo","point","radius","TypeError","undefined","R","φ1","toRadians","λ1","φ2","λ2","Δφ","Δλ","a","Math","sin","cos","c","atan2","sqrt","d","bearingTo","y","x","θ","toDegrees","finalBearingTo","midpointTo","Bx","By","φ3","λ3","intermediatePointTo","fraction","sinφ1","cosφ1","sinλ1","cosλ1","sinφ2","cosφ2","sinλ2","cosλ2","δ","A","B","z","destinationPoint","distance","bearing","sinδ","cosδ","sinθ","cosθ","asin","intersection","p1","brng1","p2","brng2","θ13","θ23","δ12","θa","acos","isNaN","θb","θ12","PI","θ21","α1","α2","α3","δ13","Δλ13","crossTrackDistanceTo","pathStart","pathEnd","δxt","alongTrackDistanceTo","δat","abs","sign","maxLatitude","φ","φMax","crossingParallels","point1","point2","latitude","λm","Δλi","λi1","λi2","lon1","lon2","rhumbDistanceTo","Δψ","log","tan","q","dist","rhumbBearingTo","rhumbDestinationPoint","rhumbMidpointTo","f1","f2","f3","isFinite","p","areaOf","polygon","closed","equals","length","push","nVertices","S","v","E","isPoleEnclosedBy","pop","ΣΔ","prevBrng","initBrng","finalBrng","enclosed","toString","format","dp","toLat","toLon","parseDMS","dmsStr","dms","String","trim","replace","split","splice","NaN","deg","test","separator","toDMS","m","s","toFixed","floor","slice","toBrng","brng","compassPoint","precision","cardinals","n","pow","cardinal","round"],"mappings":"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","sourcesContent":["/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\r\n/* Latitude/longitude spherical geodesy tools                         (c) Chris Veness 2002-2017  */\r\n/*                                                                                   MIT Licence  */\r\n/* www.movable-type.co.uk/scripts/latlong.html                                                    */\r\n/* www.movable-type.co.uk/scripts/geodesy/docs/module-latlon-spherical.html                       */\r\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\r\n\r\n'use strict';\r\nif (typeof module!='undefined' && module.exports) var Dms = require('./dms'); // ≡ import Dms from 'dms.js'\r\n\r\n\r\n/**\r\n * Library of geodesy functions for operations on a spherical earth model.\r\n *\r\n * @module   latlon-spherical\r\n * @requires dms\r\n */\r\n\r\n\r\n/**\r\n * Creates a LatLon point on the earth's surface at the specified latitude / longitude.\r\n *\r\n * @constructor\r\n * @param {number} lat - Latitude in degrees.\r\n * @param {number} lon - Longitude in degrees.\r\n *\r\n * @example\r\n *     var p1 = new LatLon(52.205, 0.119);\r\n */\r\nfunction LatLon(lat, lon) {\r\n    // allow instantiation without 'new'\r\n    if (!(this instanceof LatLon)) return new LatLon(lat, lon);\r\n\r\n    this.lat = Number(lat);\r\n    this.lon = Number(lon);\r\n}\r\n\r\n\r\n/**\r\n * Returns the distance from ‘this’ point to destination point (using haversine formula).\r\n *\r\n * @param   {LatLon} point - Latitude/longitude of destination point.\r\n * @param   {number} [radius=6371e3] - (Mean) radius of earth (defaults to radius in metres).\r\n * @returns {number} Distance between this point and destination point, in same units as radius.\r\n *\r\n * @example\r\n *     var p1 = new LatLon(52.205, 0.119);\r\n *     var p2 = new LatLon(48.857, 2.351);\r\n *     var d = p1.distanceTo(p2); // 404.3 km\r\n */\r\nLatLon.prototype.distanceTo = function(point, radius) {\r\n    if (!(point instanceof LatLon)) throw new TypeError('point is not LatLon object');\r\n    radius = (radius === undefined) ? 6371e3 : Number(radius);\r\n\r\n    // a = sin²(Δφ/2) + cos(φ1)⋅cos(φ2)⋅sin²(Δλ/2)\r\n    // tanδ = √(a) / √(1−a)\r\n    // see mathforum.org/library/drmath/view/51879.html for derivation\r\n\r\n    var R = radius;\r\n    var φ1 = this.lat.toRadians(),  λ1 = this.lon.toRadians();\r\n    var φ2 = point.lat.toRadians(), λ2 = point.lon.toRadians();\r\n    var Δφ = φ2 - φ1;\r\n    var Δλ = λ2 - λ1;\r\n\r\n    var a = Math.sin(Δφ/2) * Math.sin(Δφ/2)\r\n          + Math.cos(φ1) * Math.cos(φ2)\r\n          * Math.sin(Δλ/2) * Math.sin(Δλ/2);\r\n    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\r\n    var d = R * c;\r\n\r\n    return d;\r\n};\r\n\r\n\r\n/**\r\n * Returns the (initial) bearing from ‘this’ point to destination point.\r\n *\r\n * @param   {LatLon} point - Latitude/longitude of destination point.\r\n * @returns {number} Initial bearing in degrees from north.\r\n *\r\n * @example\r\n *     var p1 = new LatLon(52.205, 0.119);\r\n *     var p2 = new LatLon(48.857, 2.351);\r\n *     var b1 = p1.bearingTo(p2); // 156.2°\r\n */\r\nLatLon.prototype.bearingTo = function(point) {\r\n    if (!(point instanceof LatLon)) throw new TypeError('point is not LatLon object');\r\n\r\n    // tanθ = sinΔλ⋅cosφ2 / cosφ1⋅sinφ2 − sinφ1⋅cosφ2⋅cosΔλ\r\n    // see mathforum.org/library/drmath/view/55417.html for derivation\r\n\r\n    var φ1 = this.lat.toRadians(), φ2 = point.lat.toRadians();\r\n    var Δλ = (point.lon-this.lon).toRadians();\r\n    var y = Math.sin(Δλ) * Math.cos(φ2);\r\n    var x = Math.cos(φ1)*Math.sin(φ2) -\r\n            Math.sin(φ1)*Math.cos(φ2)*Math.cos(Δλ);\r\n    var θ = Math.atan2(y, x);\r\n\r\n    return (θ.toDegrees()+360) % 360;\r\n};\r\n\r\n\r\n/**\r\n * Returns final bearing arriving at destination destination point from ‘this’ point; the final bearing\r\n * will differ from the initial bearing by varying degrees according to distance and latitude.\r\n *\r\n * @param   {LatLon} point - Latitude/longitude of destination point.\r\n * @returns {number} Final bearing in degrees from north.\r\n *\r\n * @example\r\n *     var p1 = new LatLon(52.205, 0.119);\r\n *     var p2 = new LatLon(48.857, 2.351);\r\n *     var b2 = p1.finalBearingTo(p2); // 157.9°\r\n */\r\nLatLon.prototype.finalBearingTo = function(point) {\r\n    if (!(point instanceof LatLon)) throw new TypeError('point is not LatLon object');\r\n\r\n    // get initial bearing from destination point to this point & reverse it by adding 180°\r\n    return ( point.bearingTo(this)+180 ) % 360;\r\n};\r\n\r\n\r\n/**\r\n * Returns the midpoint between ‘this’ point and the supplied point.\r\n *\r\n * @param   {LatLon} point - Latitude/longitude of destination point.\r\n * @returns {LatLon} Midpoint between this point and the supplied point.\r\n *\r\n * @example\r\n *     var p1 = new LatLon(52.205, 0.119);\r\n *     var p2 = new LatLon(48.857, 2.351);\r\n *     var pMid = p1.midpointTo(p2); // 50.5363°N, 001.2746°E\r\n */\r\nLatLon.prototype.midpointTo = function(point) {\r\n    if (!(point instanceof LatLon)) throw new TypeError('point is not LatLon object');\r\n\r\n    // φm = atan2( sinφ1 + sinφ2, √( (cosφ1 + cosφ2⋅cosΔλ) ⋅ (cosφ1 + cosφ2⋅cosΔλ) ) + cos²φ2⋅sin²Δλ )\r\n    // λm = λ1 + atan2(cosφ2⋅sinΔλ, cosφ1 + cosφ2⋅cosΔλ)\r\n    // see mathforum.org/library/drmath/view/51822.html for derivation\r\n\r\n    var φ1 = this.lat.toRadians(), λ1 = this.lon.toRadians();\r\n    var φ2 = point.lat.toRadians();\r\n    var Δλ = (point.lon-this.lon).toRadians();\r\n\r\n    var Bx = Math.cos(φ2) * Math.cos(Δλ);\r\n    var By = Math.cos(φ2) * Math.sin(Δλ);\r\n\r\n    var x = Math.sqrt((Math.cos(φ1) + Bx) * (Math.cos(φ1) + Bx) + By * By);\r\n    var y = Math.sin(φ1) + Math.sin(φ2);\r\n    var φ3 = Math.atan2(y, x);\r\n\r\n    var λ3 = λ1 + Math.atan2(By, Math.cos(φ1) + Bx);\r\n\r\n    return new LatLon(φ3.toDegrees(), (λ3.toDegrees()+540)%360-180); // normalise to −180..+180°\r\n};\r\n\r\n\r\n/**\r\n * Returns the point at given fraction between ‘this’ point and specified point.\r\n *\r\n * @param   {LatLon} point - Latitude/longitude of destination point.\r\n * @param   {number} fraction - Fraction between the two points (0 = this point, 1 = specified point).\r\n * @returns {LatLon} Intermediate point between this point and destination point.\r\n *\r\n * @example\r\n *   let p1 = new LatLon(52.205, 0.119);\r\n *   let p2 = new LatLon(48.857, 2.351);\r\n *   let pMid = p1.intermediatePointTo(p2, 0.25); // 51.3721°N, 000.7073°E\r\n */\r\nLatLon.prototype.intermediatePointTo = function(point, fraction) {\r\n    if (!(point instanceof LatLon)) throw new TypeError('point is not LatLon object');\r\n\r\n    var φ1 = this.lat.toRadians(), λ1 = this.lon.toRadians();\r\n    var φ2 = point.lat.toRadians(), λ2 = point.lon.toRadians();\r\n    var sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1), sinλ1 = Math.sin(λ1), cosλ1 = Math.cos(λ1);\r\n    var sinφ2 = Math.sin(φ2), cosφ2 = Math.cos(φ2), sinλ2 = Math.sin(λ2), cosλ2 = Math.cos(λ2);\r\n\r\n    // distance between points\r\n    var Δφ = φ2 - φ1;\r\n    var Δλ = λ2 - λ1;\r\n    var a = Math.sin(Δφ/2) * Math.sin(Δφ/2)\r\n        + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ/2) * Math.sin(Δλ/2);\r\n    var δ = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\r\n\r\n    var A = Math.sin((1-fraction)*δ) / Math.sin(δ);\r\n    var B = Math.sin(fraction*δ) / Math.sin(δ);\r\n\r\n    var x = A * cosφ1 * cosλ1 + B * cosφ2 * cosλ2;\r\n    var y = A * cosφ1 * sinλ1 + B * cosφ2 * sinλ2;\r\n    var z = A * sinφ1 + B * sinφ2;\r\n\r\n    var φ3 = Math.atan2(z, Math.sqrt(x*x + y*y));\r\n    var λ3 = Math.atan2(y, x);\r\n\r\n    return new LatLon(φ3.toDegrees(), (λ3.toDegrees()+540)%360-180); // normalise lon to −180..+180°\r\n};\r\n\r\n\r\n/**\r\n * Returns the destination point from ‘this’ point having travelled the given distance on the\r\n * given initial bearing (bearing normally varies around path followed).\r\n *\r\n * @param   {number} distance - Distance travelled, in same units as earth radius (default: metres).\r\n * @param   {number} bearing - Initial bearing in degrees from north.\r\n * @param   {number} [radius=6371e3] - (Mean) radius of earth (defaults to radius in metres).\r\n * @returns {LatLon} Destination point.\r\n *\r\n * @example\r\n *     var p1 = new LatLon(51.4778, -0.0015);\r\n *     var p2 = p1.destinationPoint(7794, 300.7); // 51.5135°N, 000.0983°W\r\n */\r\nLatLon.prototype.destinationPoint = function(distance, bearing, radius) {\r\n    radius = (radius === undefined) ? 6371e3 : Number(radius);\r\n\r\n    // sinφ2 = sinφ1⋅cosδ + cosφ1⋅sinδ⋅cosθ\r\n    // tanΔλ = sinθ⋅sinδ⋅cosφ1 / cosδ−sinφ1⋅sinφ2\r\n    // see mathforum.org/library/drmath/view/52049.html for derivation\r\n\r\n    var δ = Number(distance) / radius; // angular distance in radians\r\n    var θ = Number(bearing).toRadians();\r\n\r\n    var φ1 = this.lat.toRadians();\r\n    var λ1 = this.lon.toRadians();\r\n\r\n    var sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1);\r\n    var sinδ = Math.sin(δ), cosδ = Math.cos(δ);\r\n    var sinθ = Math.sin(θ), cosθ = Math.cos(θ);\r\n\r\n    var sinφ2 = sinφ1*cosδ + cosφ1*sinδ*cosθ;\r\n    var φ2 = Math.asin(sinφ2);\r\n    var y = sinθ * sinδ * cosφ1;\r\n    var x = cosδ - sinφ1 * sinφ2;\r\n    var λ2 = λ1 + Math.atan2(y, x);\r\n\r\n    return new LatLon(φ2.toDegrees(), (λ2.toDegrees()+540)%360-180); // normalise to −180..+180°\r\n};\r\n\r\n\r\n/**\r\n * Returns the point of intersection of two paths defined by point and bearing.\r\n *\r\n * @param   {LatLon} p1 - First point.\r\n * @param   {number} brng1 - Initial bearing from first point.\r\n * @param   {LatLon} p2 - Second point.\r\n * @param   {number} brng2 - Initial bearing from second point.\r\n * @returns {LatLon|null} Destination point (null if no unique intersection defined).\r\n *\r\n * @example\r\n *     var p1 = LatLon(51.8853, 0.2545), brng1 = 108.547;\r\n *     var p2 = LatLon(49.0034, 2.5735), brng2 =  32.435;\r\n *     var pInt = LatLon.intersection(p1, brng1, p2, brng2); // 50.9078°N, 004.5084°E\r\n */\r\nLatLon.intersection = function(p1, brng1, p2, brng2) {\r\n    if (!(p1 instanceof LatLon)) throw new TypeError('p1 is not LatLon object');\r\n    if (!(p2 instanceof LatLon)) throw new TypeError('p2 is not LatLon object');\r\n\r\n    // see www.edwilliams.org/avform.htm#Intersection\r\n\r\n    var φ1 = p1.lat.toRadians(), λ1 = p1.lon.toRadians();\r\n    var φ2 = p2.lat.toRadians(), λ2 = p2.lon.toRadians();\r\n    var θ13 = Number(brng1).toRadians(), θ23 = Number(brng2).toRadians();\r\n    var Δφ = φ2-φ1, Δλ = λ2-λ1;\r\n\r\n    // angular distance p1-p2\r\n    var δ12 = 2*Math.asin( Math.sqrt( Math.sin(Δφ/2)*Math.sin(Δφ/2)\r\n        + Math.cos(φ1)*Math.cos(φ2)*Math.sin(Δλ/2)*Math.sin(Δλ/2) ) );\r\n    if (δ12 == 0) return null;\r\n\r\n    // initial/final bearings between points\r\n    var θa = Math.acos( ( Math.sin(φ2) - Math.sin(φ1)*Math.cos(δ12) ) / ( Math.sin(δ12)*Math.cos(φ1) ) );\r\n    if (isNaN(θa)) θa = 0; // protect against rounding\r\n    var θb = Math.acos( ( Math.sin(φ1) - Math.sin(φ2)*Math.cos(δ12) ) / ( Math.sin(δ12)*Math.cos(φ2) ) );\r\n\r\n    var θ12 = Math.sin(λ2-λ1)>0 ? θa : 2*Math.PI-θa;\r\n    var θ21 = Math.sin(λ2-λ1)>0 ? 2*Math.PI-θb : θb;\r\n\r\n    var α1 = θ13 - θ12; // angle 2-1-3\r\n    var α2 = θ21 - θ23; // angle 1-2-3\r\n\r\n    if (Math.sin(α1)==0 && Math.sin(α2)==0) return null; // infinite intersections\r\n    if (Math.sin(α1)*Math.sin(α2) < 0) return null;      // ambiguous intersection\r\n\r\n    var α3 = Math.acos( -Math.cos(α1)*Math.cos(α2) + Math.sin(α1)*Math.sin(α2)*Math.cos(δ12) );\r\n    var δ13 = Math.atan2( Math.sin(δ12)*Math.sin(α1)*Math.sin(α2), Math.cos(α2)+Math.cos(α1)*Math.cos(α3) );\r\n    var φ3 = Math.asin( Math.sin(φ1)*Math.cos(δ13) + Math.cos(φ1)*Math.sin(δ13)*Math.cos(θ13) );\r\n    var Δλ13 = Math.atan2( Math.sin(θ13)*Math.sin(δ13)*Math.cos(φ1), Math.cos(δ13)-Math.sin(φ1)*Math.sin(φ3) );\r\n    var λ3 = λ1 + Δλ13;\r\n\r\n    return new LatLon(φ3.toDegrees(), (λ3.toDegrees()+540)%360-180); // normalise to −180..+180°\r\n};\r\n\r\n\r\n/**\r\n * Returns (signed) distance from ‘this’ point to great circle defined by start-point and end-point.\r\n *\r\n * @param   {LatLon} pathStart - Start point of great circle path.\r\n * @param   {LatLon} pathEnd - End point of great circle path.\r\n * @param   {number} [radius=6371e3] - (Mean) radius of earth (defaults to radius in metres).\r\n * @returns {number} Distance to great circle (-ve if to left, +ve if to right of path).\r\n *\r\n * @example\r\n *   var pCurrent = new LatLon(53.2611, -0.7972);\r\n *   var p1 = new LatLon(53.3206, -1.7297);\r\n *   var p2 = new LatLon(53.1887,  0.1334);\r\n *   var d = pCurrent.crossTrackDistanceTo(p1, p2);  // -307.5 m\r\n */\r\nLatLon.prototype.crossTrackDistanceTo = function(pathStart, pathEnd, radius) {\r\n    if (!(pathStart instanceof LatLon)) throw new TypeError('pathStart is not LatLon object');\r\n    if (!(pathEnd instanceof LatLon)) throw new TypeError('pathEnd is not LatLon object');\r\n    var R = (radius === undefined) ? 6371e3 : Number(radius);\r\n\r\n    var δ13 = pathStart.distanceTo(this, R) / R;\r\n    var θ13 = pathStart.bearingTo(this).toRadians();\r\n    var θ12 = pathStart.bearingTo(pathEnd).toRadians();\r\n\r\n    var δxt = Math.asin(Math.sin(δ13) * Math.sin(θ13-θ12));\r\n\r\n    return δxt * R;\r\n};\r\n\r\n\r\n/**\r\n * Returns how far ‘this’ point is along a path from from start-point, heading towards end-point.\r\n * That is, if a perpendicular is drawn from ‘this’ point to the (great circle) path, the along-track\r\n * distance is the distance from the start point to where the perpendicular crosses the path.\r\n *\r\n * @param   {LatLon} pathStart - Start point of great circle path.\r\n * @param   {LatLon} pathEnd - End point of great circle path.\r\n * @param   {number} [radius=6371e3] - (Mean) radius of earth (defaults to radius in metres).\r\n * @returns {number} Distance along great circle to point nearest ‘this’ point.\r\n *\r\n * @example\r\n *   var pCurrent = new LatLon(53.2611, -0.7972);\r\n *   var p1 = new LatLon(53.3206, -1.7297);\r\n *   var p2 = new LatLon(53.1887,  0.1334);\r\n *   var d = pCurrent.alongTrackDistanceTo(p1, p2);  // 62.331 km\r\n */\r\nLatLon.prototype.alongTrackDistanceTo = function(pathStart, pathEnd, radius) {\r\n    if (!(pathStart instanceof LatLon)) throw new TypeError('pathStart is not LatLon object');\r\n    if (!(pathEnd instanceof LatLon)) throw new TypeError('pathEnd is not LatLon object');\r\n    var R = (radius === undefined) ? 6371e3 : Number(radius);\r\n\r\n    var δ13 = pathStart.distanceTo(this, R) / R;\r\n    var θ13 = pathStart.bearingTo(this).toRadians();\r\n    var θ12 = pathStart.bearingTo(pathEnd).toRadians();\r\n\r\n    var δxt = Math.asin(Math.sin(δ13) * Math.sin(θ13-θ12));\r\n\r\n    var δat = Math.acos(Math.cos(δ13) / Math.abs(Math.cos(δxt)));\r\n\r\n    return δat*Math.sign(Math.cos(θ12-θ13)) * R;\r\n};\r\n\r\n\r\n/**\r\n * Returns maximum latitude reached when travelling on a great circle on given bearing from this\r\n * point ('Clairaut's formula'). Negate the result for the minimum latitude (in the Southern\r\n * hemisphere).\r\n *\r\n * The maximum latitude is independent of longitude; it will be the same for all points on a given\r\n * latitude.\r\n *\r\n * @param {number} bearing - Initial bearing.\r\n * @param {number} latitude - Starting latitude.\r\n */\r\nLatLon.prototype.maxLatitude = function(bearing) {\r\n    var θ = Number(bearing).toRadians();\r\n\r\n    var φ = this.lat.toRadians();\r\n\r\n    var φMax = Math.acos(Math.abs(Math.sin(θ)*Math.cos(φ)));\r\n\r\n    return φMax.toDegrees();\r\n};\r\n\r\n\r\n/**\r\n * Returns the pair of meridians at which a great circle defined by two points crosses the given\r\n * latitude. If the great circle doesn't reach the given latitude, null is returned.\r\n *\r\n * @param {LatLon} point1 - First point defining great circle.\r\n * @param {LatLon} point2 - Second point defining great circle.\r\n * @param {number} latitude - Latitude crossings are to be determined for.\r\n * @returns {Object|null} Object containing { lon1, lon2 } or null if given latitude not reached.\r\n */\r\nLatLon.crossingParallels = function(point1, point2, latitude) {\r\n    var φ = Number(latitude).toRadians();\r\n\r\n    var φ1 = point1.lat.toRadians();\r\n    var λ1 = point1.lon.toRadians();\r\n    var φ2 = point2.lat.toRadians();\r\n    var λ2 = point2.lon.toRadians();\r\n\r\n    var Δλ = λ2 - λ1;\r\n\r\n    var x = Math.sin(φ1) * Math.cos(φ2) * Math.cos(φ) * Math.sin(Δλ);\r\n    var y = Math.sin(φ1) * Math.cos(φ2) * Math.cos(φ) * Math.cos(Δλ) - Math.cos(φ1) * Math.sin(φ2) * Math.cos(φ);\r\n    var z = Math.cos(φ1) * Math.cos(φ2) * Math.sin(φ) * Math.sin(Δλ);\r\n\r\n    if (z*z > x*x + y*y) return null; // great circle doesn't reach latitude\r\n\r\n    var λm = Math.atan2(-y, x);                  // longitude at max latitude\r\n    var Δλi = Math.acos(z / Math.sqrt(x*x+y*y)); // Δλ from λm to intersection points\r\n\r\n    var λi1 = λ1 + λm - Δλi;\r\n    var λi2 = λ1 + λm + Δλi;\r\n\r\n    return { lon1: (λi1.toDegrees()+540)%360-180, lon2: (λi2.toDegrees()+540)%360-180 }; // normalise to −180..+180°\r\n};\r\n\r\n\r\n/* Rhumb - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\r\n\r\n/**\r\n * Returns the distance travelling from ‘this’ point to destination point along a rhumb line.\r\n *\r\n * @param   {LatLon} point - Latitude/longitude of destination point.\r\n * @param   {number} [radius=6371e3] - (Mean) radius of earth (defaults to radius in metres).\r\n * @returns {number} Distance in km between this point and destination point (same units as radius).\r\n *\r\n * @example\r\n *     var p1 = new LatLon(51.127, 1.338);\r\n *     var p2 = new LatLon(50.964, 1.853);\r\n *     var d = p1.distanceTo(p2); // 40.31 km\r\n */\r\nLatLon.prototype.rhumbDistanceTo = function(point, radius) {\r\n    if (!(point instanceof LatLon)) throw new TypeError('point is not LatLon object');\r\n    radius = (radius === undefined) ? 6371e3 : Number(radius);\r\n\r\n    // see www.edwilliams.org/avform.htm#Rhumb\r\n\r\n    var R = radius;\r\n    var φ1 = this.lat.toRadians(), φ2 = point.lat.toRadians();\r\n    var Δφ = φ2 - φ1;\r\n    var Δλ = Math.abs(point.lon-this.lon).toRadians();\r\n    // if dLon over 180° take shorter rhumb line across the anti-meridian:\r\n    if (Δλ > Math.PI) Δλ -= 2*Math.PI;\r\n\r\n    // on Mercator projection, longitude distances shrink by latitude; q is the 'stretch factor'\r\n    // q becomes ill-conditioned along E-W line (0/0); use empirical tolerance to avoid it\r\n    var Δψ = Math.log(Math.tan(φ2/2+Math.PI/4)/Math.tan(φ1/2+Math.PI/4));\r\n    var q = Math.abs(Δψ) > 10e-12 ? Δφ/Δψ : Math.cos(φ1);\r\n\r\n    // distance is pythagoras on 'stretched' Mercator projection\r\n    var δ = Math.sqrt(Δφ*Δφ + q*q*Δλ*Δλ); // angular distance in radians\r\n    var dist = δ * R;\r\n\r\n    return dist;\r\n};\r\n\r\n\r\n/**\r\n * Returns the bearing from ‘this’ point to destination point along a rhumb line.\r\n *\r\n * @param   {LatLon} point - Latitude/longitude of destination point.\r\n * @returns {number} Bearing in degrees from north.\r\n *\r\n * @example\r\n *     var p1 = new LatLon(51.127, 1.338);\r\n *     var p2 = new LatLon(50.964, 1.853);\r\n *     var d = p1.rhumbBearingTo(p2); // 116.7 m\r\n */\r\nLatLon.prototype.rhumbBearingTo = function(point) {\r\n    if (!(point instanceof LatLon)) throw new TypeError('point is not LatLon object');\r\n\r\n    var φ1 = this.lat.toRadians(), φ2 = point.lat.toRadians();\r\n    var Δλ = (point.lon-this.lon).toRadians();\r\n    // if dLon over 180° take shorter rhumb line across the anti-meridian:\r\n    if (Δλ >  Math.PI) Δλ -= 2*Math.PI;\r\n    if (Δλ < -Math.PI) Δλ += 2*Math.PI;\r\n\r\n    var Δψ = Math.log(Math.tan(φ2/2+Math.PI/4)/Math.tan(φ1/2+Math.PI/4));\r\n\r\n    var θ = Math.atan2(Δλ, Δψ);\r\n\r\n    return (θ.toDegrees()+360) % 360;\r\n};\r\n\r\n\r\n/**\r\n * Returns the destination point having travelled along a rhumb line from ‘this’ point the given\r\n * distance on the  given bearing.\r\n *\r\n * @param   {number} distance - Distance travelled, in same units as earth radius (default: metres).\r\n * @param   {number} bearing - Bearing in degrees from north.\r\n * @param   {number} [radius=6371e3] - (Mean) radius of earth (defaults to radius in metres).\r\n * @returns {LatLon} Destination point.\r\n *\r\n * @example\r\n *     var p1 = new LatLon(51.127, 1.338);\r\n *     var p2 = p1.rhumbDestinationPoint(40300, 116.7); // 50.9642°N, 001.8530°E\r\n */\r\nLatLon.prototype.rhumbDestinationPoint = function(distance, bearing, radius) {\r\n    radius = (radius === undefined) ? 6371e3 : Number(radius);\r\n\r\n    var δ = Number(distance) / radius; // angular distance in radians\r\n    var φ1 = this.lat.toRadians(), λ1 = this.lon.toRadians();\r\n    var θ = Number(bearing).toRadians();\r\n\r\n    var Δφ = δ * Math.cos(θ);\r\n    var φ2 = φ1 + Δφ;\r\n\r\n    // check for some daft bugger going past the pole, normalise latitude if so\r\n    if (Math.abs(φ2) > Math.PI/2) φ2 = φ2>0 ? Math.PI-φ2 : -Math.PI-φ2;\r\n\r\n    var Δψ = Math.log(Math.tan(φ2/2+Math.PI/4)/Math.tan(φ1/2+Math.PI/4));\r\n    var q = Math.abs(Δψ) > 10e-12 ? Δφ / Δψ : Math.cos(φ1); // E-W course becomes ill-conditioned with 0/0\r\n\r\n    var Δλ = δ*Math.sin(θ)/q;\r\n    var λ2 = λ1 + Δλ;\r\n\r\n    return new LatLon(φ2.toDegrees(), (λ2.toDegrees()+540) % 360 - 180); // normalise to −180..+180°\r\n};\r\n\r\n\r\n/**\r\n * Returns the loxodromic midpoint (along a rhumb line) between ‘this’ point and second point.\r\n *\r\n * @param   {LatLon} point - Latitude/longitude of second point.\r\n * @returns {LatLon} Midpoint between this point and second point.\r\n *\r\n * @example\r\n *     var p1 = new LatLon(51.127, 1.338);\r\n *     var p2 = new LatLon(50.964, 1.853);\r\n *     var pMid = p1.rhumbMidpointTo(p2); // 51.0455°N, 001.5957°E\r\n */\r\nLatLon.prototype.rhumbMidpointTo = function(point) {\r\n    if (!(point instanceof LatLon)) throw new TypeError('point is not LatLon object');\r\n\r\n    // see mathforum.org/kb/message.jspa?messageID=148837\r\n\r\n    var φ1 = this.lat.toRadians(), λ1 = this.lon.toRadians();\r\n    var φ2 = point.lat.toRadians(), λ2 = point.lon.toRadians();\r\n\r\n    if (Math.abs(λ2-λ1) > Math.PI) λ1 += 2*Math.PI; // crossing anti-meridian\r\n\r\n    var φ3 = (φ1+φ2)/2;\r\n    var f1 = Math.tan(Math.PI/4 + φ1/2);\r\n    var f2 = Math.tan(Math.PI/4 + φ2/2);\r\n    var f3 = Math.tan(Math.PI/4 + φ3/2);\r\n    var λ3 = ( (λ2-λ1)*Math.log(f3) + λ1*Math.log(f2) - λ2*Math.log(f1) ) / Math.log(f2/f1);\r\n\r\n    if (!isFinite(λ3)) λ3 = (λ1+λ2)/2; // parallel of latitude\r\n\r\n    var p = LatLon(φ3.toDegrees(), (λ3.toDegrees()+540)%360-180); // normalise to −180..+180°\r\n\r\n    return p;\r\n};\r\n\r\n\r\n/* Area - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\r\n\r\n\r\n/**\r\n * Calculates the area of a spherical polygon where the sides of the polygon are great circle\r\n * arcs joining the vertices.\r\n *\r\n * @param   {LatLon[]} polygon - Array of points defining vertices of the polygon\r\n * @param   {number} [radius=6371e3] - (Mean) radius of earth (defaults to radius in metres).\r\n * @returns {number} The area of the polygon, in the same units as radius.\r\n *\r\n * @example\r\n *   var polygon = [new LatLon(0,0), new LatLon(1,0), new LatLon(0,1)];\r\n *   var area = LatLon.areaOf(polygon); // 6.18e9 m²\r\n */\r\nLatLon.areaOf = function(polygon, radius) {\r\n    // uses method due to Karney: osgeo-org.1560.x6.nabble.com/Area-of-a-spherical-polygon-td3841625.html;\r\n    // for each edge of the polygon, tan(E/2) = tan(Δλ/2)·(tan(φ1/2) + tan(φ2/2)) / (1 + tan(φ1/2)·tan(φ2/2))\r\n    // where E is the spherical excess of the trapezium obtained by extending the edge to the equator\r\n\r\n    var R = (radius === undefined) ? 6371e3 : Number(radius);\r\n\r\n    // close polygon so that last point equals first point\r\n    var closed = polygon[0].equals(polygon[polygon.length-1]);\r\n    if (!closed) polygon.push(polygon[0]);\r\n\r\n    var nVertices = polygon.length - 1;\r\n\r\n    var S = 0; // spherical excess in steradians\r\n    for (var v=0; v<nVertices; v++) {\r\n        var φ1 = polygon[v].lat.toRadians();\r\n        var φ2 = polygon[v+1].lat.toRadians();\r\n        var Δλ = (polygon[v+1].lon - polygon[v].lon).toRadians();\r\n        var E = 2 * Math.atan2(Math.tan(Δλ/2) * (Math.tan(φ1/2)+Math.tan(φ2/2)), 1 + Math.tan(φ1/2)*Math.tan(φ2/2));\r\n        S += E;\r\n    }\r\n\r\n    if (isPoleEnclosedBy(polygon)) S = Math.abs(S) - 2*Math.PI;\r\n\r\n    var A = Math.abs(S * R*R); // area in units of R\r\n\r\n    if (!closed) polygon.pop(); // restore polygon to pristine condition\r\n\r\n    return A;\r\n\r\n    // returns whether polygon encloses pole: sum of course deltas around pole is 0° rather than\r\n    // normal ±360°: blog.element84.com/determining-if-a-spherical-polygon-contains-a-pole.html\r\n    function isPoleEnclosedBy(polygon) {\r\n        // TODO: any better test than this?\r\n        var ΣΔ = 0;\r\n        var prevBrng = polygon[0].bearingTo(polygon[1]);\r\n        for (var v=0; v<polygon.length-1; v++) {\r\n            var initBrng = polygon[v].bearingTo(polygon[v+1]);\r\n            var finalBrng = polygon[v].finalBearingTo(polygon[v+1]);\r\n            ΣΔ += (initBrng - prevBrng + 540) % 360 - 180;\r\n            ΣΔ += (finalBrng - initBrng + 540) % 360 - 180;\r\n            prevBrng = finalBrng;\r\n        }\r\n        var initBrng = polygon[0].bearingTo(polygon[1]);\r\n        ΣΔ += (initBrng - prevBrng + 540) % 360 - 180;\r\n        // TODO: fix (intermittant) edge crossing pole - eg (85,90), (85,0), (85,-90)\r\n        var enclosed = Math.abs(ΣΔ) < 90; // 0°-ish\r\n        return enclosed;\r\n    }\r\n};\r\n\r\n\r\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\r\n\r\n\r\n/**\r\n * Checks if another point is equal to ‘this’ point.\r\n *\r\n * @param   {LatLon} point - Point to be compared against this point.\r\n * @returns {bool}   True if points are identical.\r\n *\r\n * @example\r\n *   var p1 = new LatLon(52.205, 0.119);\r\n *   var p2 = new LatLon(52.205, 0.119);\r\n *   var equal = p1.equals(p2); // true\r\n */\r\nLatLon.prototype.equals = function(point) {\r\n    if (!(point instanceof LatLon)) throw new TypeError('point is not LatLon object');\r\n\r\n    if (this.lat != point.lat) return false;\r\n    if (this.lon != point.lon) return false;\r\n\r\n    return true;\r\n};\r\n\r\n\r\n/**\r\n * Returns a string representation of ‘this’ point, formatted as degrees, degrees+minutes, or\r\n * degrees+minutes+seconds.\r\n *\r\n * @param   {string} [format=dms] - Format point as 'd', 'dm', 'dms'.\r\n * @param   {number} [dp=0|2|4] - Number of decimal places to use - default 0 for dms, 2 for dm, 4 for d.\r\n * @returns {string} Comma-separated latitude/longitude.\r\n */\r\nLatLon.prototype.toString = function(format, dp) {\r\n    return Dms.toLat(this.lat, format, dp) + ', ' + Dms.toLon(this.lon, format, dp);\r\n};\r\n\r\n\r\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\r\n\r\n/** Extend Number object with method to convert numeric degrees to radians */\r\nif (Number.prototype.toRadians === undefined) {\r\n    Number.prototype.toRadians = function() { return this * Math.PI / 180; };\r\n}\r\n\r\n/** Extend Number object with method to convert radians to numeric (signed) degrees */\r\nif (Number.prototype.toDegrees === undefined) {\r\n    Number.prototype.toDegrees = function() { return this * 180 / Math.PI; };\r\n}\r\n\r\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\r\nif (typeof module != 'undefined' && module.exports) module.exports = LatLon; // ≡ export default LatLon\r\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\r\n/* Geodesy representation conversion functions                        (c) Chris Veness 2002-2017  */\r\n/*                                                                                   MIT Licence  */\r\n/* www.movable-type.co.uk/scripts/latlong.html                                                    */\r\n/* www.movable-type.co.uk/scripts/geodesy/docs/module-dms.html                                    */\r\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\r\n\r\n'use strict';\r\n/* eslint no-irregular-whitespace: [2, { skipComments: true }] */\r\n\r\n\r\n/**\r\n * Latitude/longitude points may be represented as decimal degrees, or subdivided into sexagesimal\r\n * minutes and seconds.\r\n *\r\n * @module dms\r\n */\r\n\r\n\r\n/**\r\n * Functions for parsing and representing degrees / minutes / seconds.\r\n * @class Dms\r\n */\r\nvar Dms = {};\r\n\r\n// note Unicode Degree = U+00B0. Prime = U+2032, Double prime = U+2033\r\n\r\n\r\n/**\r\n * Parses string representing degrees/minutes/seconds into numeric degrees.\r\n *\r\n * This is very flexible on formats, allowing signed decimal degrees, or deg-min-sec optionally\r\n * suffixed by compass direction (NSEW). A variety of separators are accepted (eg 3° 37′ 09″W).\r\n * Seconds and minutes may be omitted.\r\n *\r\n * @param   {string|number} dmsStr - Degrees or deg/min/sec in variety of formats.\r\n * @returns {number} Degrees as decimal number.\r\n *\r\n * @example\r\n *     var lat = Dms.parseDMS('51° 28′ 40.12″ N');\r\n *     var lon = Dms.parseDMS('000° 00′ 05.31″ W');\r\n *     var p1 = new LatLon(lat, lon); // 51.4778°N, 000.0015°W\r\n */\r\nDms.parseDMS = function(dmsStr) {\r\n    // check for signed decimal degrees without NSEW, if so return it directly\r\n    if (typeof dmsStr == 'number' && isFinite(dmsStr)) return Number(dmsStr);\r\n\r\n    // strip off any sign or compass dir'n & split out separate d/m/s\r\n    var dms = String(dmsStr).trim().replace(/^-/, '').replace(/[NSEW]$/i, '').split(/[^0-9.,]+/);\r\n    if (dms[dms.length-1]=='') dms.splice(dms.length-1);  // from trailing symbol\r\n\r\n    if (dms == '') return NaN;\r\n\r\n    // and convert to decimal degrees...\r\n    var deg;\r\n    switch (dms.length) {\r\n        case 3:  // interpret 3-part result as d/m/s\r\n            deg = dms[0]/1 + dms[1]/60 + dms[2]/3600;\r\n            break;\r\n        case 2:  // interpret 2-part result as d/m\r\n            deg = dms[0]/1 + dms[1]/60;\r\n            break;\r\n        case 1:  // just d (possibly decimal) or non-separated dddmmss\r\n            deg = dms[0];\r\n            // check for fixed-width unseparated format eg 0033709W\r\n            //if (/[NS]/i.test(dmsStr)) deg = '0' + deg;  // - normalise N/S to 3-digit degrees\r\n            //if (/[0-9]{7}/.test(deg)) deg = deg.slice(0,3)/1 + deg.slice(3,5)/60 + deg.slice(5)/3600;\r\n            break;\r\n        default:\r\n            return NaN;\r\n    }\r\n    if (/^-|[WS]$/i.test(dmsStr.trim())) deg = -deg; // take '-', west and south as -ve\r\n\r\n    return Number(deg);\r\n};\r\n\r\n\r\n/**\r\n * Separator character to be used to separate degrees, minutes, seconds, and cardinal directions.\r\n *\r\n * Set to '\\u202f' (narrow no-break space) for improved formatting.\r\n *\r\n * @example\r\n *   var p = new LatLon(51.2, 0.33);  // 51°12′00.0″N, 000°19′48.0″E\r\n *   Dms.separator = '\\u202f';        // narrow no-break space\r\n *   var pʹ = new LatLon(51.2, 0.33); // 51° 12′ 00.0″ N, 000° 19′ 48.0″ E\r\n */\r\nDms.separator = '';\r\n\r\n\r\n/**\r\n * Converts decimal degrees to deg/min/sec format\r\n *  - degree, prime, double-prime symbols are added, but sign is discarded, though no compass\r\n *    direction is added.\r\n *\r\n * @private\r\n * @param   {number} deg - Degrees to be formatted as specified.\r\n * @param   {string} [format=dms] - Return value as 'd', 'dm', 'dms' for deg, deg+min, deg+min+sec.\r\n * @param   {number} [dp=0|2|4] - Number of decimal places to use – default 0 for dms, 2 for dm, 4 for d.\r\n * @returns {string} Degrees formatted as deg/min/secs according to specified format.\r\n */\r\nDms.toDMS = function(deg, format, dp) {\r\n    if (isNaN(deg)) return null;  // give up here if we can't make a number from deg\r\n\r\n    // default values\r\n    if (format === undefined) format = 'dms';\r\n    if (dp === undefined) {\r\n        switch (format) {\r\n            case 'd':    case 'deg':         dp = 4; break;\r\n            case 'dm':   case 'deg+min':     dp = 2; break;\r\n            case 'dms':  case 'deg+min+sec': dp = 0; break;\r\n            default:    format = 'dms'; dp = 0;  // be forgiving on invalid format\r\n        }\r\n    }\r\n\r\n    deg = Math.abs(deg);  // (unsigned result ready for appending compass dir'n)\r\n\r\n    var dms, d, m, s;\r\n    switch (format) {\r\n        default: // invalid format spec!\r\n        case 'd': case 'deg':\r\n            d = deg.toFixed(dp);                       // round/right-pad degrees\r\n            if (d<100) d = '0' + d;                    // left-pad with leading zeros (note may include decimals)\r\n            if (d<10) d = '0' + d;\r\n            dms = d + '°';\r\n            break;\r\n        case 'dm': case 'deg+min':\r\n            d = Math.floor(deg);                       // get component deg\r\n            m = ((deg*60) % 60).toFixed(dp);           // get component min & round/right-pad\r\n            if (m == 60) { m = 0; d++; }               // check for rounding up\r\n            d = ('000'+d).slice(-3);                   // left-pad with leading zeros\r\n            if (m<10) m = '0' + m;                     // left-pad with leading zeros (note may include decimals)\r\n            dms = d + '°'+Dms.separator + m + '′';\r\n            break;\r\n        case 'dms': case 'deg+min+sec':\r\n            d = Math.floor(deg);                       // get component deg\r\n            m = Math.floor((deg*3600)/60) % 60;        // get component min\r\n            s = (deg*3600 % 60).toFixed(dp);           // get component sec & round/right-pad\r\n            if (s == 60) { s = (0).toFixed(dp); m++; } // check for rounding up\r\n            if (m == 60) { m = 0; d++; }               // check for rounding up\r\n            d = ('000'+d).slice(-3);                   // left-pad with leading zeros\r\n            m = ('00'+m).slice(-2);                    // left-pad with leading zeros\r\n            if (s<10) s = '0' + s;                     // left-pad with leading zeros (note may include decimals)\r\n            dms = d + '°'+Dms.separator + m + '′'+Dms.separator + s + '″';\r\n            break;\r\n    }\r\n\r\n    return dms;\r\n};\r\n\r\n\r\n/**\r\n * Converts numeric degrees to deg/min/sec latitude (2-digit degrees, suffixed with N/S).\r\n *\r\n * @param   {number} deg - Degrees to be formatted as specified.\r\n * @param   {string} [format=dms] - Return value as 'd', 'dm', 'dms' for deg, deg+min, deg+min+sec.\r\n * @param   {number} [dp=0|2|4] - Number of decimal places to use – default 0 for dms, 2 for dm, 4 for d.\r\n * @returns {string} Degrees formatted as deg/min/secs according to specified format.\r\n */\r\nDms.toLat = function(deg, format, dp) {\r\n    var lat = Dms.toDMS(deg, format, dp);\r\n    return lat===null ? '–' : lat.slice(1)+Dms.separator + (deg<0 ? 'S' : 'N');  // knock off initial '0' for lat!\r\n};\r\n\r\n\r\n/**\r\n * Convert numeric degrees to deg/min/sec longitude (3-digit degrees, suffixed with E/W)\r\n *\r\n * @param   {number} deg - Degrees to be formatted as specified.\r\n * @param   {string} [format=dms] - Return value as 'd', 'dm', 'dms' for deg, deg+min, deg+min+sec.\r\n * @param   {number} [dp=0|2|4] - Number of decimal places to use – default 0 for dms, 2 for dm, 4 for d.\r\n * @returns {string} Degrees formatted as deg/min/secs according to specified format.\r\n */\r\nDms.toLon = function(deg, format, dp) {\r\n    var lon = Dms.toDMS(deg, format, dp);\r\n    return lon===null ? '–' : lon+Dms.separator + (deg<0 ? 'W' : 'E');\r\n};\r\n\r\n\r\n/**\r\n * Converts numeric degrees to deg/min/sec as a bearing (0°..360°)\r\n *\r\n * @param   {number} deg - Degrees to be formatted as specified.\r\n * @param   {string} [format=dms] - Return value as 'd', 'dm', 'dms' for deg, deg+min, deg+min+sec.\r\n * @param   {number} [dp=0|2|4] - Number of decimal places to use – default 0 for dms, 2 for dm, 4 for d.\r\n * @returns {string} Degrees formatted as deg/min/secs according to specified format.\r\n */\r\nDms.toBrng = function(deg, format, dp) {\r\n    deg = (Number(deg)+360) % 360;  // normalise -ve values to 180°..360°\r\n    var brng =  Dms.toDMS(deg, format, dp);\r\n    return brng===null ? '–' : brng.replace('360', '0');  // just in case rounding took us up to 360°!\r\n};\r\n\r\n\r\n/**\r\n * Returns compass point (to given precision) for supplied bearing.\r\n *\r\n * @param   {number} bearing - Bearing in degrees from north.\r\n * @param   {number} [precision=3] - Precision (1:cardinal / 2:intercardinal / 3:secondary-intercardinal).\r\n * @returns {string} Compass point for supplied bearing.\r\n *\r\n * @example\r\n *   var point = Dms.compassPoint(24);    // point = 'NNE'\r\n *   var point = Dms.compassPoint(24, 1); // point = 'N'\r\n */\r\nDms.compassPoint = function(bearing, precision) {\r\n    if (precision === undefined) precision = 3;\r\n    // note precision could be extended to 4 for quarter-winds (eg NbNW), but I think they are little used\r\n\r\n    bearing = ((bearing%360)+360)%360; // normalise to range 0..360°\r\n\r\n    var cardinals = [\r\n        'N', 'NNE', 'NE', 'ENE',\r\n        'E', 'ESE', 'SE', 'SSE',\r\n        'S', 'SSW', 'SW', 'WSW',\r\n        'W', 'WNW', 'NW', 'NNW' ];\r\n    var n = 4 * Math.pow(2, precision-1); // no of compass points at req’d precision (1=>4, 2=>8, 3=>16)\r\n    var cardinal = cardinals[Math.round(bearing*n/360)%n * 16/n];\r\n\r\n    return cardinal;\r\n};\r\n\r\n\r\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\r\nif (typeof module != 'undefined' && module.exports) module.exports = Dms; // ≡ export default Dms"]},"metadata":{},"sourceType":"module"}